---
title: "1.5.Linear.Models.Complexity.Metrics"
author: "Kevin Bruce"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: yes
    theme: united
---
 
#Load Packages/Data
```{r Load the packages and load mpq data, include=FALSE}
rm(list = ls()) #This clears the environment
dev.off()

library(dplyr)
library(ggplot2)
library(stats)
library(Rmisc)
library(here)
library(ggpmisc)
library(knitr)
library(magick)
library(gridExtra)
library(car)
library(tidyr)
library(readxl)
library(vegan)
library(tidyverse)
library(ade4)
library(MASS)
library(ellipse)
library(FactoMineR)
library(arm)
library(ape)
library(ggrepel)
library(FactoMineR)
library(ggpubr)
library(corrplot)
library(Matrix)
library(lme4)
library(TMB)
library(glmmTMB)
library(MuMIn)
library(vegan)
library(nlme)
library(randomForest)


#----------------------------------------------------------------------------------------------------------------------------------------------------------
#Set the Working Directory
setwd("~/Desktop/GitHub/Bruce_MPQ_Analysis/Data")

### 1. Habitat Volume Data
cc <- read.csv("~/Desktop/GitHub/Bruce_MPQ_Analysis/Data/BaumLab_CloudCompare_Data_Clean_11Dec2020.csv",header=TRUE, row.names=1)

str(cc)
unique(cc$timepoint)


#Change name of volume.change to hab.vol
colnames(cc)[which(names(cc)=="volume.change")] <- "hab.vol"

#Change site to a factor (for the random effect modelling)
cc$site <- as.factor(cc$site)

unique(cc$hum_dist)
cc$hum_dist <- factor(cc$hum_dist, levels = c("Very High", "Medium", "Very Low"))
cc$region.4 <- factor(cc$region.4, levels = c("Leeward", "Bay of Wrecks", "Vaskess Bay"))

cc$timepoint<- as.factor(cc$timepoint)
cc$timepoint <- factor(cc$timepoint, levels = c("2015-2017", "2017-2019", "2015-2019"))
    
#Data histrogram
hist(cc$hab.vol)
qqnorm(cc$hab.vol)
qqline(cc$hab.vol)


#----------------------------------------------------------------------------------------------------------------------------------------------------------
### 2. Fractal Dimension Data
frac <- read.csv("~/Desktop/GitHub/Bruce_MPQ_Analysis/Data/BaumLab_Fractal_Dimension_Data_Clean.csv", row.names = 1)

#Rename fractal dimension collumn to frac
colnames(frac)[which(names(frac)=="fractal.dimension")] <- "frac"

#Change site to a factor (for the random effect modeling)
frac$site <- as.factor(frac$site)


#Test for normality.....
hist(frac$frac)

    
#----------------------------------------------------------------------------------------------------------------------------------------------------------
# 3. Complexity Data
mpq <- read.csv("~/Desktop/GitHub/Bruce_MPQ_Analysis/Data/BaumLab_Complexity_ALL_Data_Clean_FINAL.11Dec2020.csv", header=TRUE, row.names = 1)

mpq <- read.csv("~/Desktop/GitHub/Bruce_MPQ_Analysis/Data/Complexity.Data.Final.21Dec2020.csv", header=TRUE, row.names = 1)


#Correct levels of hum_dist
levels(mpq$hum_dist)
mpq$hum_dist <- factor(mpq$hum_dist, levels = c("Very Low", "Medium", "Very High"))
levels(mpq$hum_dist)

#Change site to a factor (for the random effect modelling)
mpq$site <- as.factor(mpq$site)

#Create subsets for each DEM
mpq.1 <- subset (mpq, DEM == 1) 
mpq.4 <- subset (mpq, DEM == 4) 
mpq.8 <- subset (mpq, DEM == 8) 


#Range Data for 1cm DEM
mpq.1.range <- mpq.1[-54,] #Drop 2016b Site 30 MPQ1 for DEM1cm as there are cells without any coverage in the plot. 

#Transformed Data
mpq.1.range$plan.range.t2 <- log10(mpq.1.range$plan.range) #Log Transformed
mpq.1.range$plan.range.t <- sqrt(mpq.1.range$plan.range) #Square Root Transformed


#--------------------------------------------------------------------------------------------------------------------------------------------
##### Digitization Data for Random Forest Regressions and later modelling
#Import Data
mpq.dig.1 <- read.csv("~/Desktop/GitHub/Bruce_MPQ_Analysis/Data/BaumLab_Complex+Digitization_1cm_Data_11Dec20.csv", row.names = 1) #DEM 1cm
mpq.dig.4 <- read.csv("~/Desktop/GitHub/Bruce_MPQ_Analysis/Data/BaumLab_Complex+Digitization_4cm_Data_11Dec20.csv", row.names = 1) #DEM 4cm
mpq.dig.8 <- read.csv("~/Desktop/GitHub/Bruce_MPQ_Analysis/Data/BaumLab_Complex+Digitization_8cm_Data_11Dec20.csv", row.names = 1) #DEM 8cm

```

```{r Exploratory plots rug, eval=FALSE, include=FALSE}
mpq #Dataset
mpq.num <- mpq[,16:21] #numeric datagrame only

#Check the distribution of the complexity metric
hist(mpq$vrm)   #Pretty normal looking honestly....
mpq$vlog<- log(mpq$vrm) *(-1)
hist(mpq$vlog)   #Pretty normal looking honestly....

levels(mpq$year)
str(mpq$year)

#Look for outliers via Cleveland dotplot
dotchart(mpq$vrm, ylab = "Order of operations", xlab = "Concenration", main= "VRM Cleveland Dotplot")
dotchart(mpq$vrm, groups = factor(mpq$year), ylab = "Year", xlab = "Concentration", main ="VRM Cleveland Dotplot", pch=mpq$year)

#pairplot
pairs(mpq.num) #AREA_3d and rug are collinear it appears, with curvature values very similar

```

# Overview of each variable
Site = Random effect to account for difference between ppqs at a single site (not found in any of top models)

Region = Ultimately, this is to check and see whether different levels of wave energy/etc. found in select regions plays a role on the complexity around the atoll

Hum_Dist = Categorical human disturbance variable, "Very Low" is part of the baseline

sqrt.hdist.cont= Continuous human disturbance gradient value square root transformed

# Model Selection

AICc will be used anytime n/k < 40. (n = sample size, k = # of parameters in model).
- Therefore, for models with all DEM's involved, AIC will be used
- If we choose to breakdown models into indvidual DEM scales (n = 127), anything with more than K=3 will require AICc (Burnham & Anderson, 2004 --> Page 270 of document)

# Data Selection

- All data will be modelled for 1cm DEM intially, with further breakdowns done for additional DEM's at a later date

# Computing mean and standard dev
```{r compute mean, include=FALSE}
## Calculate mean, standard deviation, and standard error for each structural complexity metric

# Surface Complexity
complx <- aggregate(rug ~ year, mpq.1, mean)
complx.sd <- aggregate(rug ~ year, mpq.1, function(x) sd(x))
complx.se <- aggregate(rug ~ year, mpq.1, function(x) sd(x)/sqrt(length(x)))
complx$SD <- complx.sd$rug #Add SD to mean value dataframe
complx$SE <- complx.se$rug #Add SE to mean value dataframe
complx

# Terrain ruggedness
tr <- aggregate(vrm ~ year, mpq.1, mean)
tr.sd <- aggregate(vrm ~ year, mpq.1, function(x) sd(x))
tr.se <- aggregate(vrm ~ year, mpq.1, function(x) sd(x)/sqrt(length(x)))
tr$SD <- tr.sd$vrm #Add SD to mean value dataframe
tr$SE <- tr.se$vrm #Add SE to mean value dataframe
tr

# Fractal Dimension
fd <- aggregate(frac ~ year, frac, mean)
fd.sd <- aggregate(frac ~ year, frac, function(x) sd(x))
fd.se <- aggregate(frac ~ year, frac, function(x) sd(x)/sqrt(length(x)))
fd$SD <- fd.sd$frac #Add SD to mean value dataframe
fd$SE <- fd.se$frac #Add SE to mean value dataframe
fd

# Profile Curvature Range
pro <- aggregate(pro.range ~ year, mpq.1, mean)
pro.sd <- aggregate(pro.range ~ year, mpq.1, function(x) sd(x))
pro.se <- aggregate(pro.range ~ year, mpq.1, function(x) sd(x)/sqrt(length(x)))
pro$SD <- pro.sd$pro.range #Add SD to mean value dataframe
pro$SE <- pro.se$pro.range #Add SE to mean value df
pro

#Planform Curvature Range
plan <- aggregate(plan.range ~ year, mpq.1, mean)
plan.sd <- aggregate(plan.range ~ year, mpq.1, function(x) sd(x))
plan.se <- aggregate(plan.range ~ year, mpq.1, function(x) sd(x)/sqrt(length(x)))
plan$SD <- plan.sd$plan.range #Add SD to mean value dataframe
plan$SE <- plan.se$plan.range #Add SE to mean value df
plan


# Habitat Volume
vol <- aggregate(hab.vol ~ timepoint, cc, mean)
vol.sd <- aggregate(hab.vol ~ timepoint, cc, function(x) sd(x))
vol.se <- aggregate(hab.vol ~ timepoint, cc, function(x) sd(x)/sqrt(length(x)))
vol$SD <- vol.sd$hab.vol #Add SD to mean value dataframe
vol$SE <- vol.se$hab.vol #Add SE to mean value df
vol

```

## 1. VRM {.tabset}
### A. Investigating categorical Hum_Dist vs continuous square root transformed Hum_dist
```{r vrm fixed effect models}
#Models looking at disturbance gradient and if interaction between year&disturbance fit better
vrm1 <- lm(vrm ~ year, data = mpq.1) #Hum_Dist = Categorical
vrm2 <- lm(vrm ~ year + sqrt.hdist.cont, data = mpq.1)
vrm3 <- lm(vrm ~ year * hum_dist, data = mpq.1)
vrm4 <- lm(vrm~year*sqrt.hdist.cont, data = mpq.1)

AIC(vrm1, vrm2,vrm3,vrm4) #Top model = vrm4
summary(vrm1)
summary(vrm2)
summary(vrm3)
summary(vrm4)

# nrow(mpq.1) 127 = Any model with 3 variables or less = can use AIC

#Categorical human disturbance against region, then categorical interaction with year
#Models without interaction of disturbance added with different regions
vrm5 <- lm(vrm ~ year + hum_dist + island.side, data = mpq.1) 
vrm6 <- lm(vrm~ year + hum_dist + region.3, data = mpq.1)
vrm7 <- lm(vrm ~ year*hum_dist + island.side, data = mpq.1)
vrm8 <- lm(vrm~year*hum_dist + region.3, data = mpq.1)

AIC(vrm5, vrm6, vrm7, vrm8) #VRM5/6 fit better (without interaction)

summary(vrm7)
summary(vrm8)

#Continuous human disturbance against region, then Continuous disturbance interaction with year
vrm9 <- lm(vrm ~ year + sqrt.hdist.cont + island.side, data = mpq.1)
vrm10  <- lm(vrm ~ year + sqrt.hdist.cont + region.3, data = mpq.1)
vrm11 <- lm(vrm ~ year*sqrt.hdist.cont + island.side, data = mpq.1)
vrm12 <- lm(vrm ~ year*sqrt.hdist.cont + region.3, data = mpq.1)

AIC(vrm9, vrm10, vrm11, vrm12) #VRM11 best, followed closely by vrm 12

summary(vrm10)
summary(vrm9)
summary(vrm11)
summary(vrm12)


#AIC's for all
AIC(vrm5, vrm6, vrm7, vrm8, vrm9, vrm10,vrm11, vrm12)  #vrm11/vrm12 fit best

#-------------------------------------------------------------------------------------------------------------------------
#With Random Effect (1|site)
#Continuous disturbance- no interaction
vrm13 <- lmer(vrm~year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1)
vrm14 <- lmer(vrm~year + sqrt.hdist.cont + region.3 + (1|site), data = mpq.1)
vrm15 <- lmer(vrm~year + sqrt.hdist.cont + (1|site), data = mpq.1)
vrm16 <- lmer(vrm~year + hum_dist + (1|site), data = mpq.1)

AIC(vrm13, vrm14, vrm15, vrm16) #VRM15 best fit, but vrm13& are close  (1 - 2 AIC)

#Results of models
summary(vrm13)
summary(vrm14)
summary(vrm15)
summary(vrm16)

#With interactions
vrm17 <- lmer(vrm~year *sqrt.hdist.cont + island.side + (1|site), data = mpq.1)
vrm18 <- lmer(vrm~year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1)
vrm19 <- lmer(vrm~year * sqrt.hdist.cont + (1|site), data = mpq.1)
vrm20 <- lmer(vrm~year * hum_dist + (1|site), data = mpq.1)

AIC(vrm17, vrm18, vrm19, vrm20) #vrm19 & 17 are best fit

#Results of best fitting models
summary(vrm17)
summary(vrm18)
summary(vrm19)
summary(vrm20)

AIC(vrm1, vrm2, vrm3, vrm4, vrm5, vrm6,vrm7, vrm8, vrm9, vrm10,vrm11, vrm12, vrm13, vrm14, vrm15, vrm16,vrm17, vrm18, vrm19, vrm20 ) #Best fit models are: vrm11<vrm12<vrm9<vrm10

nrow(mpq.1) #127, meaning anything with up to 3 variables = AIC okay to use

summary(vrm11) # vrm ~ year * sqrt.hdist.cont + island.side, data = mpq.1
summary(vrm12) #vrm ~ year * sqrt.hdist.cont + region.3, data = mpq.1)

#These two are > 4AIC different than top model
summary(vrm9) #vrm ~ year + sqrt.hdist.cont + island.side, data = mpq.1
summary(vrm10) #vrm ~ year + sqrt.hdist.cont + region.3, data = mpq.1

```


### B. Final findings:

- Sqrt transformed continuous disturbance improved models vs categorical disturbance

- Interactions between year and disturbance(continuous) aided in the best fitting models selected

- Site random effect didn't improve model fit


Final Working Models (all within:

Top Model: **VRM ~ year * sqrt.hdist.cont + island.side** 

Runner Up: **VRM ~ year * sqrt.hdist.cont + region3**


TOP MODEL USING REGION3: **VRM ~ year * sqrt.hdist.cont + region3**


## 2. Surface Complexity {.tabset}
### A. Investigating categorical Hum_Dist vs continuous square root transformed Hum_dist
```{r rug fixed effect models}
#Models looking at disturbance gradient and if interaction between year&disturbance fit better
rug1 <- lm(rug ~ year + hum_dist, data = mpq.1) #Hum_Dist = Categorical
rug2 <- lm(rug ~ year + sqrt.hdist.cont, data = mpq.1)
rug3 <- lm(rug ~ year * hum_dist, data = mpq.1)
rug4 <- lm(rug~year*sqrt.hdist.cont, data = mpq.1)

AIC(rug1, rug2,rug3,rug4) #Top model = rug2 --> rug4 >rug1
summary(rug1)
summary(rug2)
summary(rug3)
summary(rug4)



#Categorical human disturbance against region, then categorical interaction with year
#Models without interaction of disturbance added with different regions
rug5 <- lm(rug ~ year + hum_dist + island.side, data = mpq.1) 
rug6 <- lm(rug~ year + hum_dist + region.3, data = mpq.1)
rug7 <- lm(rug ~ year*hum_dist + island.side, data = mpq.1)
rug8 <- lm(rug~year*hum_dist + region.3, data = mpq.1)

AIC(rug5, rug6, rug7, rug8) #Rug5/6 best fit

summary(rug5)
summary(rug6)
summary(rug7)
summary(rug8)

#Continuous human disturbance against region, then Continuous disturbance interaction with year
rug9 <- lm(rug ~ year + sqrt.hdist.cont + island.side, data = mpq.1)
rug10  <- lm(rug ~ year + sqrt.hdist.cont + region.3, data = mpq.1)
rug11 <- lm(rug ~ year*sqrt.hdist.cont + island.side, data = mpq.1)
rug12 <- lm(rug ~ year*sqrt.hdist.cont + region.3, data = mpq.1)

AIC(rug9, rug10, rug11, rug12) #rug9>rug10>rug11>rug12 

summary(rug9)
summary(rug10)
summary(rug11)
summary(rug12)


#AIC's for all
AIC(rug5, rug6, rug7, rug8, rug9, rug10,rug11, rug12)  #Rug9, 10 are best fits

#Continuous disturbance
#no interaction
rug13 <- lmer(rug~year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1)
rug14 <- lmer(rug~year + sqrt.hdist.cont + region.3 + (1|site), data = mpq.1)
rug15 <- lmer(rug~year + sqrt.hdist.cont + (1|site), data = mpq.1)
rug16 <- lmer(rug~year + hum_dist + (1|site), data = mpq.1)

AIC(rug13, rug14, rug15, rug16) #rug16 best fit

summary(rug13)
summary(rug14)
summary(rug15)
summary(rug16)

#With interactions
rug17 <- lmer(rug~year *sqrt.hdist.cont + island.side + (1|site), data = mpq.1)
rug18 <- lmer(rug~year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1)
rug19 <- lmer(rug~year * sqrt.hdist.cont + (1|site), data = mpq.1)
rug20 <- lmer(rug~year * hum_dist + (1|site), data = mpq.1)

AIC(rug17, rug18, rug19, rug20) #rug20 best fit

summary(rug17)
summary(rug18)
summary(rug19)
summary(rug20)

#Final Model selection:
AIC(rug1, rug2, rug3, rug4, rug5, rug6, rug7, rug8, rug9, rug10,rug11, rug12, rug13, rug14, rug15, rug16,rug17, rug18, rug19, rug20) #Best fitting (rug9/10/11)
AIC(rug12)
#End Result: rug9/10 models are best fit 
summary(rug9) #rug ~ year + sqrt.hdist.cont + island.side, data = mpq.1
summary(rug10) #rug ~ year + sqrt.hdist.cont + region.3, data = mpq.1 
summary(rug11) #rug ~ year * sqrt.hdist.cont + island.side, data = mpq.1
summary(rug12) #rug ~ year * sqrt.hdist.cont + region.3, data = mpq.1

```

### B. Final findings:

- Sqrt transformed continuous disturbance fits better than categorical

- Interactions between  year and disturbance(continuous) only selected in 1 of 3 top models

- Site random effect didn't improve model fit


Final Working Models:

**rug ~ year + sqrt.hdist.cont + island.side** 

**rug ~ year + sqrt.hdist.cont + region3**

**rug ~ year*sqrt.hdist.cont + region3**


TOP MODEL(S) USING REGION3: 

**rug ~ year + sqrt.hdist.cont + region3**

**rug ~ year*sqrt.hdist.cont + region3**



## 3. Fractal Dimension {.tabset}

### Fractal Dimension Dataset is normal
```{r frac appears normal, echo=FALSE}
#Data appears normal
ggplot(frac, aes(x=frac)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="Looks Normally Distributed",x="Fractal Dimension", y = "Density") + geom_vline(aes(xintercept = mean(frac)),col='red',size=0.3) + geom_vline(aes(xintercept = median(frac)),col='blue',size=0.3)

```

### A. Investigating categorical Hum_Dist vs continuous square root transformed Hum_dist
**The model output for the "best fitting" model using the categorical human disturbance value comes out all wierd. In talking with Dom about it and after showing her the equivalent model with the linear continuous human disturbance, she recommends not using the categorical variable as it makes "more modelling sense" to use the continuous with my data**

```{r frac fixed effect models}
#Models looking at disturbance gradient and if interaction between year&disturbance fit better
frac1 <- lm(frac ~ year + hum_dist, data = frac) #Hum_Dist = Categorical
frac2 <- lm(frac ~ year + sqrt.hdist.cont, data = frac)
frac3 <- lm(frac ~ year * hum_dist, data = frac)
frac4 <- lm(frac~year*sqrt.hdist.cont, data = frac)

AIC(frac1, frac2,frac3,frac4) #Top model = frac4
summary(frac1)
summary(frac2)
summary(frac3)
summary(frac4)

#Categorical human disturbance against region, then categorical interaction with year
#Models without interaction of disturbance added with different regions
frac5 <- lm(frac ~ year + hum_dist + island.side, data = frac) 
frac6 <- lm(frac~ year + hum_dist + region.3, data = frac)
frac7 <- lm(frac ~ year*hum_dist + island.side, data = frac)
frac8 <- lm(frac~year*hum_dist + region.3, data = frac)

AIC(frac5, frac6, frac7, frac8) #frac7,8 best

summary(frac5)
summary(frac6)
summary(frac7)
summary(frac8)

#Dom recommends not to include categorical human disturbance as it messes with the modelling process --> Stick to continuous variable


#Continuous human disturbance against region, then Continuous disturbance interaction with year
frac9 <- lm(frac ~ year + sqrt.hdist.cont + island.side, data = frac)
frac10  <- lm(frac ~ year + sqrt.hdist.cont + region.3, data = frac)
frac11 <- lm(frac ~ year*sqrt.hdist.cont + island.side, data = frac)
frac12 <- lm(frac ~ year*sqrt.hdist.cont + region.3, data = frac)

AIC(frac9, frac10, frac11, frac12) #Frac12<Frac11 best 2 (close ~1AIC between them)

summary(frac9)
summary(frac10)
summary(frac11)
summary(frac12)




#Continuous disturbance
#no interaction
frac13 <- lmer(frac~year + sqrt.hdist.cont + island.side + (1|site), data = frac)
frac14 <- lmer(frac~year + sqrt.hdist.cont + region.3 + (1|site), data = frac)
frac15 <- lmer(frac~year + sqrt.hdist.cont + (1|site), data = frac)
frac16 <- lmer(frac~year + hum_dist + (1|site), data = frac)

#Using AICc since we dip into (n/k<40) region, compare all using AICc and find that model frac14 best fit
AICc(frac13, frac14, frac15, frac16) #frac15 < frac16

#Results of best fitting models
summary(frac13)
summary(frac14)
summary(frac15)
summary(frac16)

#With interactions
frac17 <- lmer(frac~year *sqrt.hdist.cont + island.side + (1|site), data = frac)
frac18 <- lmer(frac~year * sqrt.hdist.cont + region.3 + (1|site), data = frac)
frac19 <- lmer(frac~year * sqrt.hdist.cont + (1|site), data = frac)
frac20 <- lmer(frac~year * hum_dist + (1|site), data = frac)

nrow(frac) #127 --> anything more than 3 variables = use AICc

AIC(frac17, frac18, frac19, frac20) #frac19 best fit 
AICc(frac17, frac18, frac19, frac20) #frac19 best fit 

summary(frac17)
summary(frac18)
summary(frac19)
summary(frac20)

#AICc needs to be used if I add 1 more parameter (currently n/k = 42)
nrow(frac) #127 total rows

#Final model selection
AICc(frac1, frac2, frac3, frac4, frac9, frac10,frac11, frac12, frac13, frac14, frac15, frac16,frac17, frac18, frac19, frac20) #Frac11,12 are best fits (with frac10 and 9 following)

#End Result: frac11/12 models are best fit 

AIC(frac12, frac11, frac10, frac9)
AICc(frac12, frac11, frac10, frac9)

summary(frac12) #frac ~ year * sqrt.hdist.cont + region.3, data = frac)
summary(frac11) #frac ~ year * sqrt.hdist.cont + island.side, data = frac

#These two are just at or more than 4AIC different than top 2 models
summary(frac10) #frac ~ year + sqrt.hdist.cont + region.3, data = frac
summary(frac9) #frac ~ year + sqrt.hdist.cont + island.side, data = frac

```

### B. Final findings:

- Sqrt transformed continuous disturbance fits best, allowing for categorical region variable to be added to models

- 2 out of 3 top model sinvolve interation between year & disturbance

- All best fit models didn't include site random effect

Final Working Model(s):

**frac ~ year * sqrt.hdist.cont + region.3** 

**frac ~ year * sqrt.hdist.cont + island.side** 

**frac ~ year + sqrt.hdist.cont + region.3**


# 4. Habitat Volume {.tabset}
### Data appears to close enough to normally distributed 
```{r non normal data distribution, echo=FALSE}
cc.2tps <- subset(cc, timepoint == "2015-2017" | timepoint == "2017-2019")

#Data is normal enough apparently (according to JKB)
ggplot(cc.2tps, aes(x=hab.vol)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="red = mean | blue = median",x="Volumetric Change (m^3)", y = "Density") + geom_vline(aes(xintercept = mean(hab.vol)),col='red',size=0.3) + geom_vline(aes(xintercept = median(hab.vol)),col='blue',size=0.3)


#Sqrt transformation
cc.2tps$hab.vol.t <- sqrt(max(cc.2tps$hab.vol + 1) - cc.2tps$hab.vol)

ggplot(cc.2tps, aes(x=hab.vol.t)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="red = mean | blue = median",x="Volumetric Change (m^3)", y = "Density") + geom_vline(aes(xintercept = mean(hab.vol.t)),col='red',size=0.3) + geom_vline(aes(xintercept = median(hab.vol.t)),col='blue',size=0.3)



#Inverse transformation for habitat volume data (#Appears to make it more normal, but also quite odd....)
cc.2tps$hab.vol.t2 <- 1/(cc.2tps$hab.vol)

#Data is normal enough apparently (according to JKB)
ggplot(cc.2tps, aes(x=hab.vol.t2)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="red = mean | blue = median",x="Volumetric Change (m^3)", y = "Density") + geom_vline(aes(xintercept = mean(hab.vol.t2)),col='red',size=0.3) + geom_vline(aes(xintercept = median(hab.vol.t2)),col='blue',size=0.3)

```

### A. Investigating categorical Hum_Dist vs continuous square root transformed Hum_dist
```{r hab volume  models}
#Models looking at disturbance gradient and if interaction between year&disturbance fit better
hab.vol1 <- lm(hab.vol ~ timepoint + hum_dist, data = cc.2tps) #Hum_Dist = Categorical
hab.vol2 <- lm(hab.vol ~ timepoint + sqrt.hdist.cont, data = cc.2tps)
hab.vol3 <- lm(hab.vol ~ timepoint * hum_dist, data = cc.2tps)
hab.vol4 <- lm(hab.vol~timepoint*sqrt.hdist.cont, data = cc.2tps)

AICc(hab.vol1, hab.vol2,hab.vol3,hab.vol4) #Top model = hab.vol3 < hab.vol1
summary(hab.vol1)
summary(hab.vol2)
summary(hab.vol3)
summary(hab.vol4)


#Categorical human disturbance against region, then categorical interaction with year
#Models without interaction of disturbance added with different regions
hab.vol5 <- lm(hab.vol ~ timepoint + hum_dist + island.side, data = cc.2tps) 
hab.vol6 <- lm(hab.vol~ timepoint + hum_dist +region.3, data = cc.2tps)
hab.vol7 <- lm(hab.vol ~ timepoint*hum_dist + island.side, data = cc.2tps)
hab.vol8 <- lm(hab.vol~timepoint*hum_dist + region.3, data = cc.2tps)

summary(hab.vol5)
summary(hab.vol6)
summary(hab.vol7)
summary(hab.vol8)

AICc(hab.vol5, hab.vol6, hab.vol7, hab.vol8) #Hab.vol5/6 best (without interaction)

#Again, Dom recommends not to include categorical human disturbance as it messes with the modelling process --> Stick to continuous variable


#Continuous human disturbance against region, then Continuous disturbance interaction with timepoint
hab.vol9 <- lm(hab.vol ~ timepoint + sqrt.hdist.cont + island.side, data = cc.2tps)
hab.vol10  <- lm(hab.vol ~ timepoint + sqrt.hdist.cont + region.3, data = cc.2tps)
hab.vol11 <- lm(hab.vol ~ timepoint*sqrt.hdist.cont + island.side, data = cc.2tps)
hab.vol12 <- lm(hab.vol ~ timepoint*sqrt.hdist.cont + region.3, data = cc.2tps)

AICc(hab.vol9, hab.vol10, hab.vol11, hab.vol12) #hab.vol9 best fit, followed by hab.vol10, hab.vol11, hab.vol12 (all extremely)

summary(hab.vol9)
summary(hab.vol10)
summary(hab.vol11)
summary(hab.vol12)  


#Continuous disturbance
#no interaction
hab.vol13 <- lmer(hab.vol~timepoint + sqrt.hdist.cont + island.side + (1|site), data = cc.2tps)
hab.vol14 <- lmer(hab.vol~timepoint + sqrt.hdist.cont + region.3 + (1|site), data = cc.2tps)
hab.vol15 <- lmer(hab.vol~timepoint + sqrt.hdist.cont + (1|site), data = cc.2tps)
hab.vol16 <- lmer(hab.vol~timepoint + hum_dist + (1|site), data = cc.2tps)

AICc(hab.vol13, hab.vol14, hab.vol15, hab.vol16) #hab.vol13 <hab.vol13 are best models

#Results of best fitting models
summary(hab.vol13)
summary(hab.vol14)
summary(hab.vol15)
summary(hab.vol16)


#With interactions
hab.vol17 <- lmer(hab.vol~timepoint *sqrt.hdist.cont + island.side + (1|site), data = cc.2tps)
hab.vol18 <- lmer(hab.vol~timepoint * sqrt.hdist.cont + region.3 + (1|site), data = cc.2tps)
hab.vol19 <- lmer(hab.vol~timepoint * sqrt.hdist.cont + (1|site), data = cc.2tps)
hab.vol20 <- lmer(hab.vol~timepoint * hum_dist + (1|site), data = cc.2tps)

AICc(hab.vol17, hab.vol18, hab.vol19, hab.vol20) #hab.vol20 best fit, but it and hab.vol18 are providing errors


#Choosing final model
nrow(cc) #Use AICc

AICc(hab.vol1, hab.vol2, hab.vol3, hab.vol4, hab.vol9, hab.vol10,hab.vol11, hab.vol12, hab.vol13, hab.vol14, hab.vol15,hab.vol17, hab.vol18, hab.vol19, hab.vol20)  #Best are: 3<9/10/11/1<12

AICc(hab.vol3,hab.vol9,hab.vol10,hab.vol11,hab.vol1,hab.vol12)

#Model Summaries
summary(hab.vol3) #hab.vol ~ timepoint * hum_dist
summary(hab.vol9) #hab.vol ~ timepoint + sqrt.hdist.cont + island.side
summary(hab.vol10) #hab.vol ~ timepoint + sqrt.hdist.cont + region.3
summary(hab.vol11) #hab.vol ~ timepoint + sqrt.hdist.cont + region.3
summary(hab.vol1) #hab.vol ~ timepoint + hum_dist
summary(hab.vol12) #hab.vol ~ timepoint * sqrt.hdist.cont + region.3
summary(hab.vol2) #hab.vol ~ timepoint * sqrt.hdist.cont + region.3
```

### B. Final findings:
- Sqrt transformed continuous disturbance fits better than categorical

- Only the latter two best fit models have interactions

- No top models selected involved site random effect

- All models compared using AICc

Final Working Model(s):

**hab.vol ~ timepoint * hum_dist**

**hab.vol ~ timepoint + sqrt.hdist.cont + region.3**

**hab.vol ~ timepoint + sqrt.hdist.cont + region.3**

**hab.vol ~ timepoint + hum_dist**

**hab.vol ~ timepoint * sqrt.hdist.cont + region.3**

**hab.vol ~ timepoint * sqrt.hdist.cont + region.3**







# 5. Profile Curvature {.tabset}
## Distribution + Transformations
```{r raw pro curv distribution, echo=FALSE}
# hist(mpq$pro.range)
ggplot(mpq.1, aes(x=pro.range)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="red = mean | blue = median",x="Pro.Curv.Range", y = "Density") + geom_vline(aes(xintercept = mean(pro.range)),col='red',size=0.3) + geom_vline(aes(xintercept = median(pro.range)),col='blue',size=0.3) + ggtitle("Raw Data (red = mean|blue=median")

#REMOVE ROW 54
mpq.1.range <- mpq.1[-54,] #Drop 2016b Site 30 MPQ1 for DEM1cm as there are cells without any coverage in the plot. 

#After dropping the outlier, it looks better!
ggplot(mpq.1.range, aes(x=pro.range)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="red = mean | blue = median",x="Pro.Curv.Range", y = "Density") + geom_vline(aes(xintercept = mean(pro.range)),col='red',size=0.3) + geom_vline(aes(xintercept = median(pro.range)),col='blue',size=0.3) + ggtitle("Raw Data with outlier removed (red = mean|blue=median)")


# lmv1 <- lm(pro.range ~ year, data = mpq)
# plot(lmv1)





mpq.1.range$pro.range.t <- sqrt(mpq.1.range$pro.range)
ggplot(mpq.1.range, aes(x=pro.range.t)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="red = mean | blue = median",x="Pro.Curv.Range. SQRT", y = "Density") + geom_vline(aes(xintercept = mean(pro.range.t)),col='red',size=0.3) + geom_vline(aes(xintercept = median(pro.range.t)),col='blue',size=0.3) + ggtitle("SquareRoot Transformed (red = mean|blue=median)")
# lmv1.1 <- lm(pro.range.t ~ year, data = mpq)
# plot(lmv1.1)



#MUCH BETTER
mpq.1.range$pro.range.log <- log10(mpq.1.range$pro.range)
ggplot(mpq.1.range, aes(x=pro.range.log)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="red = mean | blue = median",x="Pro.Curv.Range LOG", y = "Density") + geom_vline(aes(xintercept = mean(pro.range.log)),col='red',size=0.3) + geom_vline(aes(xintercept = median(pro.range.log)),col='blue',size=0.3)+ ggtitle("Log10 Transformed (red = mean|blue=median)")
# lmv2 <- lm(pro.range.t ~ year, data = mpq)
# plot(lmv2)



#BAD
mpq.1.range$pro.range.t3 <- 1/(mpq.1.range$pro.range)
ggplot(mpq.1.range, aes(x=pro.range.t3)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="red = mean | blue = median",x="Pro.Curv.Range INVERSE", y = "Density") + geom_vline(aes(xintercept = mean(pro.range.t3)),col='red',size=0.3) + geom_vline(aes(xintercept = median(pro.range.t3)),col='blue',size=0.3)+ ggtitle("Inverse Transformed (red = mean|blue=median)")
# lmv3 <- lm(pro.range.t3 ~ year, data = mpq)
# plot(lmv3)



```

## Gamma Distribution Models
**All models with the random effect fail to converge, so its difficult to compare AIC's of all models to determine top model**

```{r pro curv gamma modelling}
#nrow(mpq.1)# 127 = Any model with 3 variables or less = can use AIC

str(mpq.1.range)
#Models looking at disturbance gradient and if interaction between year&disturbance fit better
pr1 <- glm(pro.range ~ year + hum_dist, data = mpq.1.range, family= Gamma(link=log))
pr2 <- glm(pro.range ~ year + sqrt.hdist.cont, data = mpq.1.range, family= Gamma(link=log))
pr3 <- glm(pro.range ~ year * hum_dist, data = mpq.1.range, family= Gamma(link=log))
pr4 <- glm(pro.range ~ year*sqrt.hdist.cont, data = mpq.1.range, family= Gamma(link=log))

AIC(pr1, pr2,pr3,pr4) #Top model = pr2/pr1
summary(pr1)
summary(pr2)
summary(pr3)
summary(pr4)


#Categorical human disturbance against region, then categorical interaction with year
pr5 <- glm(pro.range ~ year + hum_dist + island.side, data = mpq.1.range, family= Gamma(link=log))
pr6 <- glm(pro.range ~ year + hum_dist + region.3, data = mpq.1.range, family= Gamma(link=log))
pr7 <- glm(pro.range ~ year*hum_dist + island.side, data = mpq.1.range, family= Gamma(link=log))
pr8 <- glm(pro.range ~ year*hum_dist + region.3, data = mpq.1.range, family= Gamma(link=log))

AIC(pr5, pr6, pr7, pr8) #pr5/6 fit better (without interaction)


#Continuous human disturbance against region, then Continuous disturbance interaction with year
pr9 <- glm(pro.range ~ year + sqrt.hdist.cont + island.side, data = mpq.1.range, family= Gamma(link=log))
pr10 <- glm(pro.range ~ year + sqrt.hdist.cont + region.3, data = mpq.1.range, family= Gamma(link=log))
pr11 <- glm(pro.range ~ year*sqrt.hdist.cont + island.side, data = mpq.1.range, family= Gamma(link=log))
pr12 <- glm(pro.range ~ year*sqrt.hdist.cont + region.3, data = mpq.1.range, family= Gamma(link=log))

AIC(pr9, pr10, pr11, pr12) #pr9>pr10>pr11>pr12

#AIC's for all thus far....
AIC(pr1, pr2,pr3,pr4, pr5, pr6, pr7, pr8,pr9, pr10, pr11, pr12)  #pr9 > pr10 > pr2 >pr1 ...




#Continuous disturbance- no interaction (13,14,15,16 models do not converge!)
pr13 <- glmer(pro.range ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1.range, family= Gamma(link=log))
pr14 <- glmer(pro.range ~ year + sqrt.hdist.cont + region.3 + (1|site), data = mpq.1.range, family= Gamma(link=log))
pr15 <- glmer(pro.range ~ year + sqrt.hdist.cont + (1|site), data = mpq.1.range, family= Gamma(link=log)) 
pr16 <- glmer(pro.range ~ year + hum_dist + (1|site), data = mpq.1.range, family= Gamma(link=log))

AIC(pr13, pr14, pr15, pr16) #pr15< pr13/16 < pr14 all within 2AIC

#Results of models
summary(pr15)
summary(pr16)
summary(vrm16)



#With interactions (17,18,19, 20 do not converge)
pr17 <- glmer(pro.range ~ year *sqrt.hdist.cont + island.side + (1|site), data = mpq.1.range, family= Gamma(link=log))
pr18 <- glmer(pro.range ~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1.range, family= Gamma(link=log))
pr19 <- glmer(pro.range ~ year * sqrt.hdist.cont + (1|site), data = mpq.1.range, family= Gamma(link=log))
pr20 <- glmer(pro.range ~ year * hum_dist + (1|site), data = mpq.1.range, family= Gamma(link=log))


AIC(pr17, pr18, pr19, pr20) #vrm19 <pr17 <pr20 < pr18

#Results of best fitting models
summary(pr17)
summary(pr18)
summary(pr19)
summary(pr20)


#Choosing top model
AIC(pr1, pr2,pr3,pr4, pr5, pr6, pr7, pr8,pr9, pr10, pr11, pr12, pr13, pr14, pr15, pr16,pr17, pr18, pr19, pr20) #Best fit models are: pr15< pr13 < pr13


nrow(mpq.1.range) #126 rows
 
```

## A. Log Transformed Models
```{r pro curv log transformed modelling}
#nrow(mpq.1)# 127 = Any model with 3 variables or less = can use AIC
#colnames(mpq.1.range) #Call pro.range.log

# Models year + disturbance
pr1 <- lm(pro.range.log ~ year + hum_dist, data = mpq.1.range)
pr2 <- lm(pro.range.log ~ year + sqrt.hdist.cont, data = mpq.1.range)
pr3 <- lm(pro.range.log ~ year * hum_dist, data = mpq.1.range)
pr4 <- lm(pro.range.log ~ year*sqrt.hdist.cont, data = mpq.1.range)

nrow(mpq.1.range) #126 (Anything more than 3 variables = use AICc)

AICc(pr1, pr2,pr3,pr4) #Top model = pr2/pr1
summary(pr1)
summary(pr2)
summary(pr3)
summary(pr4)


#Categorical human disturbance against region, then categorical interaction with year
pr5 <- lm(pro.range.log ~ year + hum_dist + island.side, data = mpq.1.range)
pr6 <- lm(pro.range.log ~ year + hum_dist + region.3, data = mpq.1.range)
pr7 <- lm(pro.range.log ~ year*hum_dist + island.side, data = mpq.1.range)
pr8 <- lm(pro.range.log ~ year*hum_dist + region.3, data = mpq.1.range)

AICc(pr5, pr6, pr7, pr8) #pr5/6 fit better (without interaction)
summary(pr6)

#Continuous human disturbance against region, then Continuous disturbance interaction with year
pr9 <- lm(pro.range.log ~ year + sqrt.hdist.cont + island.side, data = mpq.1.range)
pr10 <- lm(pro.range.log ~ year + sqrt.hdist.cont + region.3, data = mpq.1.range)
pr11 <- lm(pro.range.log ~ year*sqrt.hdist.cont + island.side, data = mpq.1.range)
pr12 <- lm(pro.range.log ~ year*sqrt.hdist.cont + region.3, data = mpq.1.range)

AICc(pr9, pr10, pr11, pr12) #pr9>pr10>pr11>pr12

summary(pr10)

#Continuous disturbance- no interaction (13,14,15 models do not converge!)
pr13 <- lmer(pro.range.log ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1.range)
pr14 <- lmer(pro.range.log ~ year + sqrt.hdist.cont + region.3 + (1|site),data = mpq.1.range)
pr15 <- lmer(pro.range.log ~ year + sqrt.hdist.cont + (1|site), data = mpq.1.range)
pr16 <- lmer(pro.range.log ~ year + hum_dist + (1|site), data = mpq.1.range)

AICc(pr13, pr14, pr15, pr16) #pr16 < pr15 < pr13 < pr14
#With REML = False --> pr15 < pr13 < pr16 <pr14


#Results of models
summary(pr15)
summary(pr16)

#With interactions (17,18,19 do not converge)
pr17 <- lmer(pro.range.log ~ year *sqrt.hdist.cont + island.side + (1|site), data = mpq.1.range)
pr18 <- lmer(pro.range.log ~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1.range)
pr19 <- lmer(pro.range.log ~ year * sqrt.hdist.cont + (1|site), data = mpq.1.range)
pr20 <- lmer(pro.range.log ~ year * hum_dist + (1|site), data = mpq.1.range)


AICc(pr17, pr18, pr19, pr20) #pr19/17/18

#Results of best fitting models
summary(pr19)
summary(pr17)
summary(pr18)


#Choosing top model
nrow(mpq.1.range) #USE AICc
AICc(pr1, pr2,pr3,pr4, pr5, pr6, pr7, pr8,pr9, pr10, pr11, pr12, pr13, pr14, pr15, pr16,pr17, pr18, pr19, pr20) #Best fit models are: pr9 < pr10 <pr2/5/6 < pr1 < pr16     ***pr5/6 are part of set with 2 categorical variables == best not to use

#AICc(pr1, pr2,pr3,pr4, pr5, pr6, pr7, pr8,pr9, pr10, pr11, pr12, pr13, pr14, pr15, pr16,pr17, pr18, pr19, pr20) #Best fit models are: pr9 < pr10 <pr2/5/6 < pr1 < pr16

summary(pr11)
summary(pr17)
summary(pr18)


```

## B. Final Findings:

**All models converge**

- **pro.range.log ~ year + sqrt.hdist.cont + island.side**
 
- **pro.range.log ~ year + sqrt.hdist.cont + region.3**

- **pro.range.log ~ year + sqrt.hdist.cont**

- **pro.range.log ~ year + hum_dist**






# 6. Planform Curvature {.tabset}

## Distribution + Transformations
```{r raw plan curv distribution, echo=FALSE}

# hist(mpq$plan.range)


ggplot(mpq.1, aes(x=plan.range)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="red = mean | blue = median",x="Plan.Curv.Range", y = "Density") + geom_vline(aes(xintercept = mean(plan.range)),col='red',size=0.3) + geom_vline(aes(xintercept = median(plan.range)),col='blue',size=0.3) + ggtitle("Raw Data")

#REMOVE ROW 54
mpq.1.range <- mpq.1[-54,] #Drop 2016b Site 30 MPQ1 for DEM1cm as there are cells without any coverage in the plot. 

#After dropping the outlier, it looks better!
ggplot(mpq.1.range, aes(x=plan.range)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="red = mean | blue = median",x="Plan.Curv.Range", y = "Density") + geom_vline(aes(xintercept = mean(plan.range)),col='red',size=0.3) + geom_vline(aes(xintercept = median(plan.range)),col='blue',size=0.3) + ggtitle("Raw Data with outlier removed")


# lmv1 <- lm(plan.range ~ year, data = mpq)
# plot(lmv1)





mpq.1.range$plan.range.t <- sqrt(mpq.1.range$plan.range)
ggplot(mpq.1.range, aes(x=plan.range.t)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="red = mean | blue = median",x="Plan.Curv.Range. SQRT", y = "Density") + geom_vline(aes(xintercept = mean(plan.range.t)),col='red',size=0.3) + geom_vline(aes(xintercept = median(plan.range.t)),col='blue',size=0.3) + ggtitle("SquareRoot Transformed")
# lmv1.1 <- lm(plan.range.t ~ year, data = mpq)
# plot(lmv1.1)

#REMOVE ROW 54
mpq.1.range <- mpq.1[-54,] #Drop 2016b Site 30 MPQ1 for DEM1cm as there are cells without any coverage in the plot. 

#MUCH BETTER
mpq.1.range$plan.range.log <- log10(mpq.1.range$plan.range)
ggplot(mpq.1.range, aes(x=plan.range.log)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="red = mean | blue = median",x="Plan.Curv.Range LOG", y = "Density") + geom_vline(aes(xintercept = mean(plan.range.log)),col='red',size=0.3) + geom_vline(aes(xintercept = median(plan.range.log)),col='blue',size=0.3)+ ggtitle("Log10 Transformed")
# lmv2 <- lm(plan.range.log ~ year, data = mpq)
# plot(lmv2)



#BAD
mpq.1.range$plan.range.t3 <- 1/(mpq.1.range$plan.range)
ggplot(mpq.1.range, aes(x=plan.range.t3)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white", bins= 30)+
 geom_density(alpha=.2, fill="#FF6666") + labs(title="red = mean | blue = median",x="Plan.Curv.Range INVERSE", y = "Density") + geom_vline(aes(xintercept = mean(plan.range.t3)),col='red',size=0.3) + geom_vline(aes(xintercept = median(plan.range.t3)),col='blue',size=0.3)+ ggtitle("Inverse Transformed")
# lmv3 <- lm(plan.range.t3 ~ year, data = mpq)
# plot(lmv3)



```


## Gamma Distribution Models

**All models with the random effect fail to converge, so its difficult to compare AIC's of all models to determine top model**

```{r plan curv gamma modelling}
#nrow(mpq.1)# 127 = Any model with 3 variables or less = can use AIC

#str(mpq.1.range)

#Models looking at disturbance gradient and if interaction between year&disturbance fit better
plan1 <- glm(plan.range ~ year + hum_dist, data = mpq.1.range, family= Gamma(link=log))
plan2 <- glm(plan.range ~ year + sqrt.hdist.cont, data = mpq.1.range, family= Gamma(link=log))
plan3 <- glm(plan.range ~ year * hum_dist, data = mpq.1.range, family= Gamma(link=log))
plan4 <- glm(plan.range ~ year*sqrt.hdist.cont, data = mpq.1.range, family= Gamma(link=log))

AIC(plan1, plan2,plan3,plan4) #Top model = plan1/2
summary(plan1)
summary(plan2)
summary(plan3)
summary(plan4)


#Categorical human disturbance against region, then categorical interaction with year
plan5 <- glm(plan.range ~ year + hum_dist + island.side, data = mpq.1.range, family= Gamma(link=log))
plan6 <- glm(plan.range ~ year + hum_dist + region.3, data = mpq.1.range, family= Gamma(link=log))
plan7 <- glm(plan.range ~ year*hum_dist + island.side, data = mpq.1.range, family= Gamma(link=log))
plan8 <- glm(plan.range ~ year*hum_dist + region.3, data = mpq.1.range, family= Gamma(link=log))

AIC(plan5, plan6, plan7, plan8) #plan5/6 fit better (without interaction)


#Continuous human disturbance against region, then Continuous disturbance interaction with year
plan9 <- glm(plan.range ~ year + sqrt.hdist.cont + island.side, data = mpq.1.range, family= Gamma(link=log))
plan10 <- glm(plan.range ~ year + sqrt.hdist.cont + region.3, data = mpq.1.range, family= Gamma(link=log))
plan11 <- glm(plan.range ~ year*sqrt.hdist.cont + island.side, data = mpq.1.range, family= Gamma(link=log))
plan12 <- glm(plan.range ~ year*sqrt.hdist.cont + region.3, data = mpq.1.range, family= Gamma(link=log))

AIC(plan9, plan10, plan11, plan12) #plan9 < plan10 < plan11 <plan12

#AIC's for all thus far....
AIC(plan1, plan2,plan3,plan4, plan5, plan6, plan7, plan8,plan9, plan10, plan11, plan12)  #plan2/9 < plan1/10




#Continuous disturbance- no interaction (plan15 does not converge!)
plan13 <- glmer(plan.range ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1.range, family= Gamma(link=log))
plan14 <- glmer(plan.range ~ year + sqrt.hdist.cont + region.3 + (1|site), data = mpq.1.range, family= Gamma(link=log))
plan15 <- glmer(plan.range ~ year + sqrt.hdist.cont + (1|site), data = mpq.1.range, family= Gamma(link=log)) 
plan16 <- glmer(plan.range ~ year + hum_dist + (1|site), data = mpq.1.range, family= Gamma(link=log))

AIC(plan13, plan14, plan15, plan16) #plan15< plan13/16 < plan14 all within 2AIC

#Results of models
summary(plan15)
summary(plan16)



#With interactions (plan17,18,19 do not converge)
plan17 <- glmer(plan.range ~ year *sqrt.hdist.cont + island.side + (1|site), data = mpq.1.range, family= Gamma(link=log))
plan18 <- glmer(plan.range ~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1.range, family= Gamma(link=log))
plan19 <- glmer(plan.range ~ year * sqrt.hdist.cont + (1|site), data = mpq.1.range, family= Gamma(link=log))
plan20 <- glmer(plan.range ~ year * hum_dist + (1|site), data = mpq.1.range, family= Gamma(link=log))


AIC(plan17, plan18, plan19, plan20) #vrm19 <plan17 <plan20 < plan18

#Results of best fitting models
summary(plan17)
summary(plan18)
summary(plan19)
summary(plan20)


#Choosing top model
AIC(plan1, plan2,plan3,plan4, plan5, plan6, plan7, plan8,plan9, plan10, plan11, plan12, plan13, plan14, plan15, plan16,plan17, plan18, plan19, plan20) #Best fit models are: plan15< plan13 < plan13


nrow(mpq.1.range) #126 rows
 
```

## A. Log Transformed Models

```{r plano curv log transformed modelling}
#nrow(mpq.1)# 127 = Any model with 3 variables or less = can use AIC
#colnames(mpq.1.range) #Call plano.range.t2

# Models year + disturbance
plan1 <- lm(plan.range.log ~ year + hum_dist, data = mpq.1.range)
plan2 <- lm(plan.range.log ~ year + sqrt.hdist.cont, data = mpq.1.range)
plan3 <- lm(plan.range.log ~ year * hum_dist, data = mpq.1.range)
plan4 <- lm(plan.range.log ~ year*sqrt.hdist.cont, data = mpq.1.range)

AICc(plan1, plan2,plan3,plan4) #Top model = plan2/plan1
summary(plan1)
summary(plan2)
summary(plan3)
summary(plan4)


#Categorical human disturbance against region, then categorical interaction with year
plan5 <- lm(plan.range.log ~ year + hum_dist + island.side, data = mpq.1.range)
plan6 <- lm(plan.range.log ~ year + hum_dist + region.3, data = mpq.1.range)
plan7 <- lm(plan.range.log ~ year*hum_dist + island.side, data = mpq.1.range)
plan8 <- lm(plan.range.log ~ year*hum_dist + region.3, data = mpq.1.range)

AICc(plan5, plan6, plan7, plan8) #plan5/6 fit better (without interaction)
summary(plan5)
summary(plan6) #Conflicting region ~human disturbance, so good thing these weren't selected

#Continuous human disturbance against region, then Continuous disturbance interaction with year
plan9 <- lm(plan.range.log ~ year + sqrt.hdist.cont + island.side, data = mpq.1.range)
plan10 <- lm(plan.range.log ~ year + sqrt.hdist.cont + region.3, data = mpq.1.range)
plan11 <- lm(plan.range.log ~ year*sqrt.hdist.cont + island.side, data = mpq.1.range)
plan12 <- lm(plan.range.log ~ year*sqrt.hdist.cont + region.3, data = mpq.1.range)

AICc(plan9, plan10, plan11, plan12) #plan9>plan10>plan11>plan12

summary(plan9)
summary(plan10)

#Continuous disturbance- no interaction (13,14,15 models do not converge!)
plan13 <- lmer(plan.range.log ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1.range)
plan14 <- lmer(plan.range.log ~ year + sqrt.hdist.cont + region.3 + (1|site), data = mpq.1.range)
plan15 <- lmer(plan.range.log ~ year + sqrt.hdist.cont + (1|site), data = mpq.1.range)
plan16 <- lmer(plan.range.log ~ year + hum_dist + (1|site), data = mpq.1.range)

AICc(plan13, plan14, plan15, plan16) #plan16 < plan15 < plan13 < plan14

#Results of models
summary(plan15)
summary(plan16)


#With interactions (17,18,19 do not converge)
plan17 <- lmer(plan.range.log ~ year *sqrt.hdist.cont + island.side + (1|site), data = mpq.1.range)
plan18 <- lmer(plan.range.log ~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1.range)
plan19 <- lmer(plan.range.log ~ year * sqrt.hdist.cont + (1|site), data = mpq.1.range)
plan20 <- lmer(plan.range.log ~ year * hum_dist + (1|site), data = mpq.1.range)


AICc(plan17, plan18, plan19, plan20) #plan20

#Results of best fitting models
summary(plan20)


#Choosing top model
AICc(plan1, plan2,plan3,plan4, plan5, plan6, plan7, plan8,plan9, plan10, plan11, plan12, plan13, plan14, plan15, plan16,plan17, plan18, plan19, plan20) #Best fit models are: plan 2 < plan9 < plan10/1  *** plan5/6/7/8 all have multiple categorical variables, so DOM recommends not using

#AICc(plan1, plan2,plan3,plan4, plan5, plan6, plan7, plan8,plan9, plan10, plan11, plan12, plan13, plan14, plan15, plan16,plan17, plan18, plan19, plan20) #Best fit models are: plan 2 < plan9 < plan10/1 <plan5/6 


```


## B. Final Findings

**All models converge ---> Top models are: plan2 < plan9 < plan10/1 **

- **plan.range.log ~ year + sqrt.hdist.cont **
 
- **plan.range.log ~ year + sqrt.hdist.cont + island.side**

- **plan.range.log ~ year + sqrt.hdist.cont + region.3**

- **plan.range.log ~ year + hum_dist**









# 8. Random Forest {.tabset}

This is to determine the significant contributing morphologies to each metric of complexity

```{r random forest prep, eval=FALSE, include=FALSE}
#Load Data
mpq.dig.full.1cm <- read.csv("~/Desktop/GitHub/Bruce_MPQ_Analysis/Data/BaumLab_Complex+Digitization_FULL_1cm_Data_11Jan21.csv", row.names = 1)
mpq.dig.semi.1cm<- read.csv("~/Desktop/GitHub/Bruce_MPQ_Analysis/Data/BaumLab_Complex+Digitization_SEMI_1cm_Data_11Jan21.csv", row.names = 1)
mpq.dig.simple.1cm<- read.csv("~/Desktop/GitHub/Bruce_MPQ_Analysis/Data/BaumLab_Complex+Digitization_SIMPLE_1cm_Data_11Jan21.csv", row.names = 1)


#Create a full dataframe + dataframe without abiotic structures
#Full Dataframe

#1. VRM
vrm.per.1cm.full <- mpq.dig.full.1cm[c(13,21:44)] #1cm full df, all
vrm.per.1cm.full.live <- mpq.dig.full.1cm[c(13,21:40,43:44)]  #no abiotic str 
 
vrm.per.1cm.semi <- mpq.dig.semi.1cm[c(13,21:42)] #1cm semi df, all
vrm.per.1cm.semi.live <- mpq.dig.semi.1cm[c(13,21:38,41:42)] #no abiotic str

vrm.per.1cm.simple <- mpq.dig.simple.1cm[c(13,21:27)] #1cm simple df, all
vrm.per.1cm.simple.live <-mpq.dig.simple.1cm[c(13,21:25,26:27)] #no abiotic str


#2. Surface Complexity




#### TEST TO SEE HOW ^^THESE LOOK AND COME BACK TO DO REST.... ####


















# SCRIPT FOR 3 DIFFERENT RESOLUTIONS I ATTEMPTED EARLIER- DISREGARD

#Create Data Matrix of complexity metric ~ morphology percentages
#Drop collumns of rare non-coral morphs and abiotic structure (sand, rubble)
# #1. VRM
# vrm.per.1cm <- mpq.dig.1[c(13,21:39,42:43)] #1cm
# vrm.per.4cm <- mpq.dig.4[c(13,20:42)] #4cm
# vrm.per.8cm <- mpq.dig.8[c(13,20:42)] #8cm
# 
# #2. Rug
# rug.per.1cm <- mpq.dig.1[c(12,21:43)] #1cm
# rug.per.4cm <- mpq.dig.4[c(12,20:42)] #4cm
# rug.per.8cm <- mpq.dig.8[c(12,20:42)] #8cm
# 
# #2. Fractal Dimension
# frac.forest <- mpq.dig.1[c(20:43)] #1cm
# 
# #4a. Profile Curvature Mean
# pro.mean.per.1cm <- mpq.dig.1[c(16,21:43)] #1cm
# pro.mean.per.4cm <- mpq.dig.4[c(16,20:42)] #4cm
# pro.mean.per.8cm <- mpq.dig.8[c(16,20:42)] #8cm
# 
# #4b. Profile Curvature Range
# pro.range.per.1cm <- mpq.dig.1[c(17,21:43)] #1cm
# pro.range.per.4cm <- mpq.dig.4[c(17,20:42)] #4cm
# pro.range.per.8cm <- mpq.dig.8[c(17,20:42)] #8cm
# 
# #5. Planform Curvature Mean
# plan.mean.per.1cm <- mpq.dig.1[c(18,21:43)] #1cm
# plan.mean.per.4cm <- mpq.dig.4[c(18,20:42)] #4cm
# plan.mean.per.8cm <- mpq.dig.8[c(18,20:42)] #8cm
# 
# #4b. Planform Curvature Range
# plan.range.per.1cm <- mpq.dig.1[c(19,21:43)] #1cm
# plan.range.per.4cm <- mpq.dig.4[c(19,20:42)] #4cm
# plan.range.per.8cm <- mpq.dig.8[c(19,20:42)] #8cm



```


## Computing Optimal mtry values
### VRM - FULL (optimal mtry = 4)
```{r surface complexity random forrest, include=FALSE}
#<------------------ Rugosity ------------------------>
#Create training Sample with 300 observations
nrow(vrm.per.1cm.full) #80
train=sample(1:nrow(vrm.per.1cm.full),80) #80 rows

#Run Random Forest
vrm.classify1 <- randomForest(vrm ~., data = vrm.per.1cm.full, subset = train, ntree = 500)
print(vrm.classify1)
plot(vrm.classify1)

#Testing to see what # of predictors chosen at each split is best (aka has lowest OOB)
ncol(vrm.per.1cm.full) #There are 24 predictors in this dataset

oob.err=double(24)
test.err=double(24)

#mtry is no of Variables randomly chosen at each split
for(mtry in 1:24) 
{
  rf=randomForest(vrm ~ . , data = vrm.per.1cm.full , subset = train,mtry=mtry,ntree=100) 
  oob.err[mtry] = rf$mse[100] #Error of all Trees fitted
  
  pred<-predict(rf,vrm.per.1cm.full[-train,]) #Predictions on Test Set for each Tree
  test.err[mtry]= with(vrm.per.1cm.full[-train,], mean( (vrm - pred)^2)) #Mean Squared Test Error
  
  cat(mtry," ") #printing the output to the console
  
}

#Get the test error
test.err

#Get the OOB error
oob.err


#Plot it
matplot(1:mtry , cbind(oob.err,test.err), pch=1 , col=c("red","blue"),type="b",ylab="Mean Squared Error",xlab="Number of Predictors Considered at each Split")
legend("topright",legend=c("Out of Bag Error"),pch=1, col=c("red"))


```

### VRM - FULL (no abiotic) (optimal mtry = 4)
```{r vrm full no abiotic random forrest, include=FALSE}
#<------------------ Rugosity ------------------------>
#Create training Sample with 300 observations
nrow(vrm.per.1cm.full.live) #80
train2=sample(1:nrow(vrm.per.1cm.full.live),80) #80 rows

#Run Random Forest
vrm.classify2 <- randomForest(vrm ~., data = vrm.per.1cm.full.live, subset = train2, ntree = 100)
print(vrm.classify2)
plot(vrm.classify2)


#Testing to see what # of predictors chosen at each split is best (aka has lowest OOB)
ncol(vrm.per.1cm.full.live) #There are 23-1 = 22 predictors in this dataset

oob.err=double(22)
test.err=double(22)

#mtry is no of Variables randomly chosen at each split
for(mtry in 1:22) 
{
  rf=randomForest(vrm ~ . , data = vrm.per.1cm.full.live , subset = train2,mtry=mtry,ntree=100) 
  oob.err[mtry] = rf$mse[100] #Error of all Trees fitted
  
  pred<-predict(rf,vrm.per.1cm.full.live[-train2,]) #Predictions on Test Set for each Tree
  test.err[mtry]= with(vrm.per.1cm.full.live[-train2,], mean( (vrm - pred)^2)) #Mean Squared Test Error
  
  cat(mtry," ") #printing the output to the console
  
}

#Get the test error
test.err

#Get the OOB error
oob.err


#Plot it
matplot(1:mtry , cbind(oob.err,test.err), pch=1 , col=c("red","blue"),type="b",ylab="Mean Squared Error",xlab="Number of Predictors Considered at each Split")
legend("topright",legend=c("Out of Bag Error"),pch=1, col=c("red"))


```

### VRM - Semi (optimal mtry = 2)
```{r surface complexity random forrest, include=FALSE}
#<------------------ Rugosity ------------------------>
#Create training Sample with 300 observations
nrow(vrm.per.1cm.semi) #80
train3=sample(1:nrow(vrm.per.1cm.semi),80) #80 rows

#Run Random Forest
vrm.classify3 <- randomForest(vrm ~., data = vrm.per.1cm.semi, subset = train3, ntree = 100)
print(vrm.classify3)
plot(vrm.classify3)


#Testing to see what # of predictors chosen at each split is best (aka has lowest OOB)
ncol(vrm.per.1cm.semi) #There are 23-1 = 22 predictors in this dataset

oob.err=double(22)
test.err=double(22)

#mtry is no of Variables randomly chosen at each split
for(mtry in 1:22) 
{
  rf=randomForest(vrm ~ . , data = vrm.per.1cm.semi , subset = train,mtry=mtry,ntree=100) 
  oob.err[mtry] = rf$mse[100] #Error of all Trees fitted
  
  pred<-predict(rf,vrm.per.1cm.semi[-train3,]) #Predictions on Test Set for each Tree
  test.err[mtry]= with(vrm.per.1cm.semi[-train3,], mean( (vrm - pred)^2)) #Mean Squared Test Error
  
  cat(mtry," ") #printing the output to the console
  
}

#Get the test error
test.err

#Get the OOB error
oob.err


#Plot it
matplot(1:mtry , cbind(oob.err,test.err), pch=1 , col=c("red","blue"),type="b",ylab="Mean Squared Error",xlab="Number of Predictors Considered at each Split")
legend("topright",legend=c("Out of Bag Error"),pch=1, col=c("red"))


```

### VRM - Semi (no abiotic) (optimal mtry = 4) (set of 10: 4,9,5,4,3,7,5,3,4,4 = mode =4) 
```{r surface complexity random forrest, include=FALSE}
#<------------------ Rugosity ------------------------>
#Create training Sample with 300 observations
nrow(vrm.per.1cm.semi.live) #80
train4=sample(1:nrow(vrm.per.1cm.semi.live),80) #80 rows

#Run Random Forest
vrm.classify4 <- randomForest(vrm ~., data = vrm.per.1cm.semi.live, subset = train4, ntree = 100)
print(vrm.classify4)
plot(vrm.classify4)


#Testing to see what # of predictors chosen at each split is best (aka has lowest OOB)
ncol(vrm.per.1cm.semi.live) #There are 21-1 = 20 predictors in this dataset

oob.err=double(20)
test.err=double(20)

#mtry is no of Variables randomly chosen at each split
for(mtry in 1:20) 
{
  rf=randomForest(vrm ~ . , data = vrm.per.1cm.semi.live , subset = train,mtry=mtry,ntree=100) 
  oob.err[mtry] = rf$mse[100] #Error of all Trees fitted
  
  pred<-predict(rf,vrm.per.1cm.semi.live[-train4,]) #Predictions on Test Set for each Tree
  test.err[mtry]= with(vrm.per.1cm.semi.live[-train4,], mean( (vrm - pred)^2)) #Mean Squared Test Error
  
  cat(mtry," ") #printing the output to the console
  
}

#Get the test error
test.err

#Get the OOB error
oob.err


#Plot it
matplot(1:mtry , cbind(oob.err,test.err), pch=1 , col=c("red","blue"),type="b",ylab="Mean Squared Error",xlab="Number of Predictors Considered at each Split")
legend("topright",legend=c("Out of Bag Error"),pch=1, col=c("red"))


```

### VRM - Simple (optimal mtry = 3)
```{r surface complexity random forrest, include=FALSE}
#<------------------ Rugosity ------------------------>
#Create training Sample with 300 observations
nrow(vrm.per.1cm.simple) #80
train5=sample(1:nrow(vrm.per.1cm.simple),80) #80 rows

#Run Random Forest
vrm.classify5 <- randomForest(vrm ~., data = vrm.per.1cm.simple, subset = train5, ntree = 100)
print(vrm.classify5)
plot(vrm.classify5)


#Testing to see what # of predictors chosen at each split is best (aka has lowest OOB)
ncol(vrm.per.1cm.simple) #There are 8-1 = 7 predictors in this dataset

oob.err=double(7)
test.err=double(7)

#mtry is no of Variables randomly chosen at each split
for(mtry in 1:7) 
{
  rf=randomForest(vrm ~ . , data = vrm.per.1cm.simple , subset = train5,mtry=mtry,ntree=100) 
  oob.err[mtry] = rf$mse[100] #Error of all Trees fitted
  
  pred<-predict(rf,vrm.per.1cm.simple[-train5,]) #Predictions on Test Set for each Tree
  test.err[mtry]= with(vrm.per.1cm.simple[-train5,], mean( (vrm - pred)^2)) #Mean Squared Test Error
  
  cat(mtry," ") #printing the output to the console
  
}

#Get the test error
test.err

#Get the OOB error
oob.err


#Plot it
matplot(1:mtry , cbind(oob.err,test.err), pch=1 , col=c("red","blue"),type="b",ylab="Mean Squared Error",xlab="Number of Predictors Considered at each Split")
legend("topright",legend=c("Out of Bag Error"),pch=1, col=c("red"))


```

### VRM - Semi (no abiotic) (optimal mtry = 3)
```{r surface complexity random forrest, include=FALSE}
#<------------------ Rugosity ------------------------>
#Create training Sample with 300 observations
nrow(vrm.per.1cm.simple.live) #80
train6=sample(1:nrow(vrm.per.1cm.simple.live),80) #80 rows

#Run Random Forest
vrm.classify6 <- randomForest(vrm ~., data = vrm.per.1cm.simple.live, subset = train6, ntree = 100)
print(vrm.classify6)
plot(vrm.classify6)


#Testing to see what # of predictors chosen at each split is best (aka has lowest OOB)
ncol(vrm.per.1cm.simple.live) #There are 8-1 = 7 predictors in this dataset

oob.err=double(7)
test.err=double(7)

#mtry is no of Variables randomly chosen at each split
for(mtry in 1:7) 
{
  rf=randomForest(vrm ~ . , data = vrm.per.1cm.simple.live , subset = train6,mtry=mtry,ntree=100) 
  oob.err[mtry] = rf$mse[100] #Error of all Trees fitted
  
  pred<-predict(rf,vrm.per.1cm.simple.live[-train6,]) #Predictions on Test Set for each Tree
  test.err[mtry]= with(vrm.per.1cm.simple.live[-train6,], mean( (vrm - pred)^2)) #Mean Squared Test Error
  
  cat(mtry," ") #printing the output to the console
  
}

#Get the test error
test.err

#Get the OOB error
oob.err


#Plot it
matplot(1:mtry , cbind(oob.err,test.err), pch=1 , col=c("red","blue"),type="b",ylab="Mean Squared Error",xlab="Number of Predictors Considered at each Split")
legend("topright",legend=c("Out of Bag Error"),pch=1, col=c("red"))


```


## Computing Random Forests with Semi dataframe

### VRM- semi
```{r vrm semi random forest}
############## 1cm DEM SEMI DATABASE #################
#Random Forrest
set.seed(2)
vrm.classify3 <- randomForest(vrm~., data = vrm.per.1cm.semi, mtry =4, ntree = 100)
print(vrm.classify3)
names(vrm.classify3)

#Make a dataframe with predictor names and their importance
imp.vrm3.full.1cm <- importance(vrm.classify3)
imp.vrm3.full.1cm <- data.frame(predictors = rownames(imp.vrm3.full.1cm), imp.vrm3.full.1cm)

colnames(imp.vrm3.full.1cm)

# Order the predictor levels by importance
imp.vrm3.full.1cm.sort <- arrange(imp.vrm3.full.1cm, desc(IncNodePurity))
imp.vrm3.full.1cm.sort$predictors <- factor(imp.vrm3.full.1cm.sort$predictors, levels = imp.vrm3.full.1cm.sort$predictors)

# Select the top 10 predictors
imp.vrm3.full.1cm.top.5 <- imp.vrm3.full.1cm.sort[1:5, ]
imp.vrm3.full.1cm.top.10 <- imp.vrm3.full.1cm.sort[1:10, ]


# Plot top morphologies
ggplot(imp.vrm3.full.1cm.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for RUG 1cm classification")

```

### VRM semi (no abiotic)
```{r}
############## 1cm DEM SEMI DATABASE - ABIOTIC (RUBBLE/SAND) #################
#Random Forrest
vrm.classify4 <- randomForest(vrm~., data = vrm.per.1cm.semi.live, ntree = 100)
print(vrm.classify4)
names(vrm.classify4)

#Make a dataframe with predictor names and their importance
imp.vrm4.full.1cm <- importance(vrm.classify4)
imp.vrm4.full.1cm <- data.frame(predictors = rownames(imp.vrm4.full.1cm), imp.vrm4.full.1cm)

colnames(imp.vrm4.full.1cm)

# Order the predictor levels by importance
imp.vrm4.full.1cm.sort <- arrange(imp.vrm4.full.1cm, desc(IncNodePurity))
imp.vrm4.full.1cm.sort$predictors <- factor(imp.vrm4.full.1cm.sort$predictors, levels = imp.vrm4.full.1cm.sort$predictors)

# Select the top 10 predictors
imp.vrm4.full.1cm.top.5 <- imp.vrm4.full.1cm.sort[1:5, ]
imp.vrm4.full.1cm.top.10 <- imp.vrm4.full.1cm.sort[1:10, ]


# Plot top morphologies
ggplot(imp.vrm4.full.1cm.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for RUG 1cm classification")

```






```{r simple and full databases if I do}
############## 1cm DEM FULL DATABASE - ABIOTIC (RUBBLE/SAND) #################
#Random Forrest
set.seed(2)
vrm.classify2 <- randomForest(vrm~., data = vrm.per.1cm.full.live, ntree = 100)
print(vrm.classify2)
names(vrm.classify2)

#Make a dataframe with predictor names and their importance
imp.vrm2.full.1cm <- importance(vrm.classify2)
imp.vrm2.full.1cm <- data.frame(predictors = rownames(imp.vrm2.full.1cm), imp.vrm2.full.1cm)

colnames(imp.vrm2.full.1cm)

# Order the predictor levels by importance
imp.vrm2.full.1cm.sort <- arrange(imp.vrm2.full.1cm, desc(IncNodePurity))
imp.vrm2.full.1cm.sort$predictors <- factor(imp.vrm2.full.1cm.sort$predictors, levels = imp.vrm2.full.1cm.sort$predictors)

# Select the top 10 predictors
imp.vrm2.full.1cm.top.5 <- imp.vrm2.full.1cm.sort[1:5, ]
imp.vrm2.full.1cm.top.10 <- imp.vrm2.full.1cm.sort[1:10, ]


# Plot top morphologies
ggplot(imp.vrm2.full.1cm.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for RUG 1cm classification")


############## 1cm DEM SIMPLE DATABASE #################
#Random Forrest
set.seed(2)
vrm.classify5 <- randomForest(vrm~., data = vrm.per.1cm.simple, ntree = 100, mtry = 2)
print(vrm.classify5)
names(vrm.classify5)

#Make a dataframe with predictor names and their importance
imp.vrm5.full.1cm <- importance(vrm.classify5)
imp.vrm5.full.1cm <- data.frame(predictors = rownames(imp.vrm5.full.1cm), imp.vrm5.full.1cm)

colnames(imp.vrm5.full.1cm)

# Order the predictor levels by importance
imp.vrm5.full.1cm.sort <- arrange(imp.vrm5.full.1cm, desc(IncNodePurity))
imp.vrm5.full.1cm.sort$predictors <- factor(imp.vrm5.full.1cm.sort$predictors, levels = imp.vrm5.full.1cm.sort$predictors)

# Select the top 10 predictors
imp.vrm5.full.1cm.top.5 <- imp.vrm5.full.1cm.sort[1:5, ]
imp.vrm5.full.1cm.top.10 <- imp.vrm5.full.1cm.sort[1:10, ]


# Plot top morphologies
ggplot(imp.vrm5.full.1cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for VRM 1cm classification")

```







#Disregard below

```{r}
###########

mean(vrm.classify1$mse) #0.0001727692

vrm.classify1$err.rate[,1] #NUKK



#Make a dataframe with predictor names and their importance
imp.vrm.full.1cm <- importance(vrm.classify1)
imp.vrm.full.1cm <- data.frame(predictors = rownames(imp.vrm.full.1cm), imp.vrm.full.1cm)

colnames(imp.vrm.full.1cm)

# Order the predictor levels by importance
imp.vrm.full.1cm.sort <- arrange(imp.vrm.full.1cm, desc(IncNodePurity))
imp.vrm.full.1cm.sort$predictors <- factor(imp.vrm.full.1cm.sort$predictors, levels = imp.vrm.full.1cm.sort$predictors)

# Select the top 10 predictors
imp.vrm.full1.1cm.top.5 <- imp.vrm.full.1cm.sort[1:5, ]
imp.vrm.full1.1cm.top.10 <- imp.vrm.full.1cm.sort[1:10, ]


# Plot top morphologies
ggplot(imp.vrm.full1.1cm.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for RUG 1cm classification")

```







## 8a. Surface Complexity
```{r surface complexity random forrest, include=FALSE}
#<------------------ Rugosity ------------------------>
# 1cm DEM 
#Random Forrest
set.seed(2)
rug.classify <- randomForest(rug~., data = rug.per.1cm, ntree = 100)
print(rug.classify)
names(rug.classify)

#Make a dataframe with predictor names and their importance
imp.rug.1cm <- importance(rug.classify)
imp.rug.1cm <- data.frame(predictors = rownames(imp.rug.1cm), imp.rug.1cm)

colnames(imp.rug.1cm)

# Order the predictor levels by importance
imp.rug.1cm.sort <- arrange(imp.rug.1cm, desc(IncNodePurity))
imp.rug.1cm.sort$predictors <- factor(imp.rug.1cm.sort$predictors, levels = imp.rug.1cm.sort$predictors)

# Select the top 10 predictors
imp.rug.1cm.top.5 <- imp.rug.1cm.sort[1:5, ]
imp.rug.1cm.top.20 <- imp.rug.1cm.sort[1:20, ]


# Plot top morphologies
# ggplot(imp.rug.1cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for RUG 1cm classification")

# ggplot(imp.rug.1cm.top.20, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 10 most important morphologies for RUG 1cm classification")


################### 4cm DEM ###########################
#Random Forrest
set.seed(2)
rug.classify.4cm <- randomForest(rug~., data = rug.per.4cm, ntree = 100)
print(rug.classify.4cm)
names(rug.classify.4cm)

#Make a dataframe with predictor names and their importance
imp.rug.4cm <- importance(rug.classify.4cm)
imp.rug.4cm <- data.frame(predictors = rownames(imp.rug.4cm), imp.rug.4cm)

colnames(imp.rug.4cm)

# Order the predictor levels by importance
imp.rug.4cm.sort <- arrange(imp.rug.4cm, desc(IncNodePurity))
imp.rug.4cm.sort$predictors <- factor(imp.rug.4cm.sort$predictors, levels = imp.rug.4cm.sort$predictors)

# Select the top 10 predictors
imp.rug.4cm.top.5 <- imp.rug.4cm.sort[1:5, ]
imp.rug.4cm.top.10 <- imp.rug.4cm.sort[1:10, ]


# Plot top morphologies
#ggplot(imp.rug.4cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for RUG 4cm classification")

#ggplot(imp.rug.4cm.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 10 most important morphologies for RUG 4cm classification")

################### 8cm DEM ###########################
#Random Forrest
set.seed(2)
rug.classify.8cm <- randomForest(rug~., data = rug.per.8cm, ntree = 100)
print(rug.classify.8cm)
names(rug.classify.8cm)

#Make a dataframe with predictor names and their importance
imp.rug.8cm <- importance(rug.classify.8cm)
imp.rug.8cm <- data.frame(predictors = rownames(imp.rug.8cm), imp.rug.8cm)

colnames(imp.rug.8cm)

# Order the predictor levels by importance
imp.rug.8cm.sort <- arrange(imp.rug.8cm, desc(IncNodePurity))
imp.rug.8cm.sort$predictors <- factor(imp.rug.8cm.sort$predictors, levels = imp.rug.8cm.sort$predictors)

# Select the top 10 predictors
imp.rug.8cm.top.5 <- imp.rug.8cm.sort[1:5, ]
imp.rug.8cm.top.10 <- imp.rug.8cm.sort[1:10, ]


# Plot top morphologies
#ggplot(imp.rug.8cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for RUG 8cm classification")

#ggplot(imp.rug.8cm.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 10 most important morphologies for RUG 8cm classification")


```

### 1cm DEM 
```{r 1cm DEM surface rug morphologies, echo=FALSE}
ggplot(imp.rug.1cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for RUG 1cm classification")

```

### 4cm DEM
```{r 4cm dem rug random forest, echo=FALSE}
ggplot(imp.rug.4cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for RUG 4cm classification")

```

### 8cm DEM
```{r 8cm dem rug Rforrest, echo=FALSE}
ggplot(imp.rug.8cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for RUG 4cm classification")
```

## 8b. VRM
```{r vrm random forrest, include=FALSE}
################### 1cm DEM ###########################
#Random Forrest
set.seed(2)
vrm.classify <- randomForest(vrm~., data = vrm.per.1cm, ntree = 100)
print(vrm.classify)
names(vrm.classify)

#Make a dataframe with predictor names and their importance
imp.vrm.1cm <- importance(vrm.classify)
imp.vrm.1cm <- data.frame(predictors = rownames(imp.vrm.1cm), imp.vrm.1cm)

colnames(imp.vrm.1cm)

# Order the predictor levels by importance
imp.vrm.1cm.sort <- arrange(imp.vrm.1cm, desc(IncNodePurity))
imp.vrm.1cm.sort$predictors <- factor(imp.vrm.1cm.sort$predictors, levels = imp.vrm.1cm.sort$predictors)

# Select the top 10 predictors
imp.vrm.1cm.sort.top.5 <- imp.vrm.1cm.sort[1:5, ]
imp.vrm.1cm.sort.top.10 <- imp.vrm.1cm.sort[1:10, ]


# Plot top morphologies
# ggplot(imp.vrm.1cm.sort.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for VRM 1cm classification")

# ggplot(imp.vrm.1cm.sort.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 10 most important morphologies for VRM 1cm classification")


################### 4cm DEM ###########################
#Random Forrest
set.seed(2)
vrm.classify.4cm <- randomForest(vrm~., data = vrm.per.4cm, ntree = 100)
print(vrm.classify.4cm)
names(vrm.classify.4cm)

#Make a dataframe with predictor names and their importance
imp.vrm.4cm <- importance(vrm.classify.4cm)
imp.vrm.4cm <- data.frame(predictors = rownames(imp.vrm.4cm), imp.vrm.4cm)

colnames(imp.vrm.4cm)

# Order the predictor levels by importance
imp.vrm.4cm.sort <- arrange(imp.vrm.4cm, desc(IncNodePurity))
imp.vrm.4cm.sort$predictors <- factor(imp.vrm.4cm.sort$predictors, levels = imp.vrm.4cm.sort$predictors)

# Select the top 10 predictors
imp.vrm.4cm.top.5 <- imp.vrm.4cm.sort[1:5, ]
imp.vrm.4cm.top.10 <- imp.vrm.4cm.sort[1:10, ]


# Plot top morphologies
# ggplot(imp.vrm.4cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for VRM 4cm classification")

#ggplot(imp.vrm.4cm.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 10 most important morphologies for VRM 4cm classification")

################### 8cm DEM ###########################
#Random Forrest
set.seed(2)
vrm.classify.8cm <- randomForest(vrm~., data = vrm.per.8cm, ntree = 100)
print(vrm.classify.8cm)
names(vrm.classify.8cm)

#Make a dataframe with predictor names and their importance
imp.vrm.8cm <- importance(vrm.classify.8cm)
imp.vrm.8cm <- data.frame(predictors = rownames(imp.vrm.8cm), imp.vrm.8cm)

colnames(imp.vrm.8cm)

# Order the predictor levels by importance
imp.vrm.8cm.sort <- arrange(imp.vrm.8cm, desc(IncNodePurity))
imp.vrm.8cm.sort$predictors <- factor(imp.vrm.8cm.sort$predictors, levels = imp.vrm.8cm.sort$predictors)

# Select the top 10 predictors
imp.vrm.8cm.top.5 <- imp.vrm.8cm.sort[1:5, ]
imp.vrm.8cm.top.10 <- imp.vrm.8cm.sort[1:10, ]


# Plot top morphologies
#ggplot(imp.vrm.8cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for VRM 8cm classification")

#ggplot(imp.vrm.8cm.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 10 most important morphologies for VRM 8cm classification")


```

### 1cm 
```{r vrm random forest 1cm, echo=FALSE}
ggplot(imp.vrm.1cm.sort.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for VRM 1cm classification")
```

### 4cm
```{r 4cm vrm random forest, echo=FALSE}
ggplot(imp.vrm.4cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for VRM 4cm classification")

```

### 8cm
```{r 8cm vrm random forest, echo= FALSE}
ggplot(imp.vrm.8cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for VRM 8cm classification")
```


## 8c. Fractal Dimension

```{r fractal dimension random frrest, include = FALSE}
#Random Forrest
set.seed(2)
frac.classify <- randomForest(fractal.dimension~., data = frac.forest, ntree = 100)
print(frac.classify)
names(frac.classify)

#Make a dataframe with predictor names and their importance
imp.frac.1cm <- importance(frac.classify)
imp.frac.1cm <- data.frame(predictors = rownames(imp.frac.1cm), imp.frac.1cm)

colnames(imp.frac.1cm)

# Order the predictor levels by importance
imp.frac.1cm.sort <- arrange(imp.frac.1cm, desc(IncNodePurity))
imp.frac.1cm.sort$predictors <- factor(imp.frac.1cm.sort$predictors, levels = imp.frac.1cm.sort$predictors)

# Select the top 10 predictors
imp.frac.1cm.sort.top.5 <- imp.frac.1cm.sort[1:5, ]
imp.frac.1cm.sort.top.10 <- imp.frac.1cm.sort[1:10, ]


# Plot top morphologies
# ggplot(imp.frac.1cm.sort.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for Fractal Dimension")

# ggplot(imp.frac.1cm.sort.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 10 most important morphologies for Fractal Dimension")


```

```{r frac plot randomforrest, echo= FALSE}
ggplot(imp.frac.1cm.sort.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for Fractal Dimension")
```

## 8d. Profile Curvature Mean
```{r profile curv mean random forrest, include=FALSE}
################### 1cm DEM ###########################
#Random Forrest
set.seed(2)
pro.m.classify <- randomForest(pro.curv~., data = pro.mean.per.1cm, ntree = 100)
print(pro.m.classify)
names(pro.m.classify)

#Make a dataframe with predictor names and their importance
imp.pro.m.1cm <- importance(pro.m.classify)
imp.pro.m.1cm <- data.frame(predictors = rownames(imp.pro.m.1cm), imp.pro.m.1cm)

colnames(imp.pro.m.1cm)

# Order the predictor levels by importance
imp.pro.m.1cm.sort <- arrange(imp.pro.m.1cm, desc(IncNodePurity))
imp.pro.m.1cm.sort$predictors <- factor(imp.pro.m.1cm.sort$predictors, levels = imp.pro.m.1cm.sort$predictors)

# Select the top 10 predictors
imp.pro.m.1cm.sort.top.5 <- imp.pro.m.1cm.sort[1:5, ]
imp.pro.m.1cm.sort.top.10 <- imp.pro.m.1cm.sort[1:10, ]


# Plot top morphologies
# ggplot(imp.pro.m.1cm.sort.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for ProCurv Mean 1cm classification")

# ggplot(imp.pro.m.1cm.sort.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 10 most important morphologies for ProCurv Mean 1cm classification")


################### 4cm DEM ###########################
#Random Forrest
set.seed(2)
pro.m.classify.4cm <- randomForest(pro.curv~., data = pro.mean.per.4cm, ntree = 100)
print(pro.m.classify.4cm)
names(pro.m.classify.4cm)

#Make a dataframe with predictor names and their importance
imp.pro.m.4cm <- importance(pro.m.classify.4cm)
imp.pro.m.4cm <- data.frame(predictors = rownames(imp.pro.m.4cm), imp.pro.m.4cm)

colnames(imp.pro.m.4cm)

# Order the predictor levels by importance
imp.pro.m.4cm.sort <- arrange(imp.pro.m.4cm, desc(IncNodePurity))
imp.pro.m.4cm.sort$predictors <- factor(imp.pro.m.4cm.sort$predictors, levels = imp.pro.m.4cm.sort$predictors)

# Select the top 10 predictors
imp.pro.m.4cm.top.5 <- imp.pro.m.4cm.sort[1:5, ]
imp.pro.m.4cm.top.10 <- imp.pro.m.4cm.sort[1:10, ]


# Plot top morphologies
# ggplot(imp.pro.m.4cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for ProCurv Mean 4cm classification")

#ggplot(imp.pro.m.4cm.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 10 most important morphologies for ProCurv Mean 4cm classification")

################### 8cm DEM ###########################
#Random Forrest
set.seed(2)
pro.m.classify.8cm <- randomForest(pro.curv~., data = pro.mean.per.8cm, ntree = 100)
print(pro.m.classify.8cm)
names(pro.m.classify.8cm)

#Make a dataframe with predictor names and their importance
imp.pro.m.8cm <- importance(pro.m.classify.8cm)
imp.pro.m.8cm <- data.frame(predictors = rownames(imp.pro.m.8cm), imp.pro.m.8cm)

colnames(imp.pro.m.8cm)

# Order the predictor levels by importance
imp.pro.m.8cm.sort <- arrange(imp.pro.m.8cm, desc(IncNodePurity))
imp.pro.m.8cm.sort$predictors <- factor(imp.pro.m.8cm.sort$predictors, levels = imp.pro.m.8cm.sort$predictors)

# Select the top 10 predictors
imp.pro.m.8cm.top.5 <- imp.pro.m.8cm.sort[1:5, ]
imp.pro.m.8cm.top.10 <- imp.pro.m.8cm.sort[1:10, ]


# Plot top morphologies
#ggplot(imp.pro.m.8cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for ProCurv Mean 8cm classification")

#ggplot(imp.pro.m.8cm.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 10 most important morphologies for ProCurv Mean 8cm classification")


```

### 1cm
```{r 1cmDEM pro. mean random forrest, echo=FALSE}
ggplot(imp.pro.m.1cm.sort.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for ProCurv Mean 1cm classification")
```

### 4cm
```{r 4cm DEM pro.curv mean, echo=FALSE}
ggplot(imp.pro.m.4cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for ProCurv Mean 4cm classification")
```

### 8cm 
```{r 8cm dem pro.curv mean, echo=FALSE}
ggplot(imp.pro.m.8cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for ProCurv Mean 8cm classification")
```


## 8e. Profile Curvature Range
```{r pro range random forrest, include=FALSE}
################### 1cm DEM ###########################
#Random Forrest
set.seed(2)
pro.r.classify <- randomForest(pro.range~., data = pro.range.per.1cm, ntree = 100)
print(pro.r.classify)
names(pro.r.classify)

#Make a dataframe with predictor names and their importance
imp.pro.m.1cm <- importance(pro.r.classify)
imp.pro.m.1cm <- data.frame(predictors = rownames(imp.pro.m.1cm), imp.pro.m.1cm)

colnames(imp.pro.m.1cm)

# Order the predictor levels by importance
imp.pro.m.1cm.sort <- arrange(imp.pro.m.1cm, desc(IncNodePurity))
imp.pro.m.1cm.sort$predictors <- factor(imp.pro.m.1cm.sort$predictors, levels = imp.pro.m.1cm.sort$predictors)

# Select the top 10 predictors
imp.pro.m.1cm.sort.top.5 <- imp.pro.m.1cm.sort[1:5, ]
imp.pro.m.1cm.sort.top.10 <- imp.pro.m.1cm.sort[1:10, ]


# Plot top morphologies
# ggplot(imp.pro.m.1cm.sort.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for ProCurv Mean 1cm classification")

# ggplot(imp.pro.m.1cm.sort.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 10 most important morphologies for ProCurv Mean 1cm classification")


################### 4cm DEM ###########################
#Random Forrest
set.seed(2)
pro.m.classify.4cm <- randomForest(pro.curv~., data = pro.mean.per.4cm, ntree = 100)
print(pro.m.classify.4cm)
names(pro.m.classify.4cm)

#Make a dataframe with predictor names and their importance
imp.pro.m.4cm <- importance(pro.m.classify.4cm)
imp.pro.m.4cm <- data.frame(predictors = rownames(imp.pro.m.4cm), imp.pro.m.4cm)

colnames(imp.pro.m.4cm)

# Order the predictor levels by importance
imp.pro.m.4cm.sort <- arrange(imp.pro.m.4cm, desc(IncNodePurity))
imp.pro.m.4cm.sort$predictors <- factor(imp.pro.m.4cm.sort$predictors, levels = imp.pro.m.4cm.sort$predictors)

# Select the top 10 predictors
imp.pro.m.4cm.top.5 <- imp.pro.m.4cm.sort[1:5, ]
imp.pro.m.4cm.top.10 <- imp.pro.m.4cm.sort[1:10, ]


# Plot top morphologies
# ggplot(imp.pro.m.4cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for ProCurv Mean 4cm classification")

#ggplot(imp.pro.m.4cm.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 10 most important morphologies for ProCurv Mean 4cm classification")

################### 8cm DEM ###########################
#Random Forrest
set.seed(2)
pro.m.classify.8cm <- randomForest(pro.curv~., data = pro.mean.per.8cm, ntree = 100)
print(pro.m.classify.8cm)
names(pro.m.classify.8cm)

#Make a dataframe with predictor names and their importance
imp.pro.m.8cm <- importance(pro.m.classify.8cm)
imp.pro.m.8cm <- data.frame(predictors = rownames(imp.pro.m.8cm), imp.pro.m.8cm)

colnames(imp.pro.m.8cm)

# Order the predictor levels by importance
imp.pro.m.8cm.sort <- arrange(imp.pro.m.8cm, desc(IncNodePurity))
imp.pro.m.8cm.sort$predictors <- factor(imp.pro.m.8cm.sort$predictors, levels = imp.pro.m.8cm.sort$predictors)

# Select the top 10 predictors
imp.pro.m.8cm.top.5 <- imp.pro.m.8cm.sort[1:5, ]
imp.pro.m.8cm.top.10 <- imp.pro.m.8cm.sort[1:10, ]


# Plot top morphologies
#ggplot(imp.pro.m.8cm.top.5, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 5 most important morphologies for ProCurv Mean 8cm classification")

#ggplot(imp.pro.m.8cm.top.10, aes(x = predictors, y = IncNodePurity)) + geom_bar(stat = "identity", fill = "indianred") + coord_flip() + ggtitle("Top 10 most important morphologies for ProCurv Mean 8cm classification")


```




# Simplified, Clean Models from help with DOM
```{r testing to see if island side vs region3 should be used}
#Incorporating Island Side
global.vrma <- lmer(vrm~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
global.vrmb <- lmer(vrm~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)


vrm1 <- lm(vrm ~ year, data = mpq.1cm) 
vrm2 <- lm(vrm ~ year + sqrt.hdist.cont, data = mpq.1cm)
vrm3 <- lm(vrm ~ year * sqrt.hdist.cont, data = mpq.1cm)
vrm4 <- lm(vrm ~ sqrt.hdist.cont, data = mpq.1cm)

vrm5 <- lm(vrm ~ year + sqrt.hdist.cont + region.3, data = mpq.1cm) 
vrm6 <- lm(vrm ~ year * sqrt.hdist.cont + region.3, data = mpq.1cm)
vrm7 <- lm(vrm~ year + region.3, data = mpq.1cm)

vrm8 <- lmer(vrm ~ year + sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
vrm9 <- lmer(vrm ~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
vrm10 <- lmer(vrm ~ year + sqrt.hdist.cont + (1|site), data = mpq.1cm)
vrm11 <- lmer(vrm ~ year * sqrt.hdist.cont + (1|site), data = mpq.1cm)
vrm12 <- lmer(vrm ~ year + (1|site), data = mpq.1cm)
vrm13 <- lmer(vrm ~ year + (1|site), data = mpq.1cm)


vrm14 <- lm(vrm ~ year + sqrt.hdist.cont + island.side, data = mpq.1cm) 
vrm15 <- lm(vrm ~ year * sqrt.hdist.cont + island.side, data = mpq.1cm)
vrm16 <- lm(vrm~ year + island.side, data = mpq.1cm)
vrm17 <- lmer(vrm ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
vrm18 <- lmer(vrm ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)


## AIC model selection
AIC_vrm.table <- model.sel(vrm1,vrm2,vrm3,vrm4,vrm5,vrm6,vrm7,vrm8,vrm9,vrm10,vrm11,vrm12, vrm13, vrm14, vrm15, vrm16, vrm17, vrm18, global.vrma, global.vrmb)

# ## AIC summary table 
# names(AIC_vrm.table) <- c("(Int)", "Year", "Human Disturbance", "Disturbance*Year", "Region", "Family", "Model.Class","df", "LL", "AICc", "AICc", "Weight")
# AIC_vrm.table$weight <- c(akaike.weights(AIC_vrm.table$AICc)$weights)
# 
# summary(vrm6)
# 
# <- ---------
global.ruga <- lmer(rug ~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
global.rugb <- lmer(rug ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)


rug1 <- lm(rug ~ year, data = mpq.1cm) 
rug2 <- lm(rug ~ year + sqrt.hdist.cont, data = mpq.1cm)
rug3 <- lm(rug ~ year * sqrt.hdist.cont, data = mpq.1cm)
rug4 <- lm(rug ~ sqrt.hdist.cont, data = mpq.1cm)

rug5 <- lm(rug ~ year + sqrt.hdist.cont + region.3, data = mpq.1cm) 
rug6 <- lm(rug ~ year * sqrt.hdist.cont + region.3, data = mpq.1cm)
rug7 <- lm(rug~ year + region.3, data = mpq.1cm)

rug8 <- lmer(rug ~ year + sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
rug9 <- lmer(rug ~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
rug10 <- lmer(rug ~ year + sqrt.hdist.cont + (1|site), data = mpq.1cm)
rug11 <- lmer(rug ~ year * sqrt.hdist.cont + (1|site), data = mpq.1cm)
rug12 <- lmer(rug ~ year + (1|site), data = mpq.1cm)
rug13 <- lmer(rug ~ year + (1|site), data = mpq.1cm)


rug14 <- lm(rug ~ year + sqrt.hdist.cont + island.side, data = mpq.1cm) 
rug15 <- lm(rug ~ year * sqrt.hdist.cont + island.side, data = mpq.1cm)
rug16 <- lm(rug~ year + island.side, data = mpq.1cm)
rug17 <- lmer(rug ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
rug18 <- lmer(rug ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)


## AIC model selection
AIC_rug.table <- model.sel(rug1,rug2,rug3,rug4,rug5,rug6,rug7,rug8,rug9,rug10,rug11,rug12, rug13, rug14, rug15, rug16, rug17, rug18, global.ruga, global.rugb)

#<---------------
global.fraca <- lmer(fractal.dimension ~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
global.fracb <- lmer(fractal.dimension ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)


frac1 <- lm(fractal.dimension ~ year, data = mpq.1cm) 
frac2 <- lm(fractal.dimension ~ year + sqrt.hdist.cont, data = mpq.1cm)
frac3 <- lm(fractal.dimension ~ year * sqrt.hdist.cont, data = mpq.1cm)
frac4 <- lm(fractal.dimension ~ sqrt.hdist.cont, data = mpq.1cm)

frac5 <- lm(fractal.dimension ~ year + sqrt.hdist.cont + region.3, data = mpq.1cm) 
frac6 <- lm(fractal.dimension ~ year * sqrt.hdist.cont + region.3, data = mpq.1cm)
frac7 <- lm(fractal.dimension~ year + region.3, data = mpq.1cm)

frac8 <- lmer(fractal.dimension ~ year + sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
frac9 <- lmer(fractal.dimension ~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
frac10 <- lmer(fractal.dimension ~ year + sqrt.hdist.cont + (1|site), data = mpq.1cm)
frac11 <- lmer(fractal.dimension ~ year * sqrt.hdist.cont + (1|site), data = mpq.1cm)
frac12 <- lmer(fractal.dimension ~ year + (1|site), data = mpq.1cm)
frac13 <- lmer(fractal.dimension ~ year + (1|site), data = mpq.1cm)


frac14 <- lm(fractal.dimension ~ year + sqrt.hdist.cont + island.side, data = mpq.1cm) 
frac15 <- lm(fractal.dimension ~ year * sqrt.hdist.cont + island.side, data = mpq.1cm)
frac16 <- lm(fractal.dimension~ year + island.side, data = mpq.1cm)
frac17 <- lmer(fractal.dimension ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
frac18 <- lmer(fractal.dimension ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)


## AIC model selection
AIC_frac.table <- model.sel(frac1,frac2,frac3,frac4,frac5,frac6,frac7,frac8,frac9,frac10,frac11,frac12, frac13, frac14, frac15, frac16, frac17, frac18, global.fraca, global.fracb)

# <- ---------
global.pro.rangea <- lmer(pro.range.log ~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
global.pro.rangeb <- lmer(pro.range.log ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)


pro.range1 <- lm(pro.range.log ~ year, data = mpq.1cm) 
pro.range2 <- lm(pro.range.log ~ year + sqrt.hdist.cont, data = mpq.1cm)
pro.range3 <- lm(pro.range.log ~ year * sqrt.hdist.cont, data = mpq.1cm)
pro.range4 <- lm(pro.range.log ~ sqrt.hdist.cont, data = mpq.1cm)

pro.range5 <- lm(pro.range.log ~ year + sqrt.hdist.cont + region.3, data = mpq.1cm) 
pro.range6 <- lm(pro.range.log ~ year * sqrt.hdist.cont + region.3, data = mpq.1cm)
pro.range7 <- lm(pro.range.log~ year + region.3, data = mpq.1cm)

pro.range8 <- lmer(pro.range.log ~ year + sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
pro.range9 <- lmer(pro.range.log ~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
pro.range10 <- lmer(pro.range.log ~ year + sqrt.hdist.cont + (1|site), data = mpq.1cm)
pro.range11 <- lmer(pro.range.log ~ year * sqrt.hdist.cont + (1|site), data = mpq.1cm)
pro.range12 <- lmer(pro.range.log ~ year + (1|site), data = mpq.1cm)
pro.range13 <- lmer(pro.range.log ~ year + (1|site), data = mpq.1cm)


pro.range14 <- lm(pro.range.log ~ year + sqrt.hdist.cont + island.side, data = mpq.1cm) 
pro.range15 <- lm(pro.range.log ~ year * sqrt.hdist.cont + island.side, data = mpq.1cm)
pro.range16 <- lm(pro.range.log~ year + island.side, data = mpq.1cm)
pro.range17 <- lmer(pro.range.log ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
pro.range18 <- lmer(pro.range.log ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)


## AIC model selection
AIC_pro.range.table <- model.sel(pro.range1,pro.range2,pro.range3,pro.range4,pro.range5,pro.range6,pro.range7,pro.range8,pro.range9,pro.range10,pro.range11,pro.range12, pro.range13, pro.range14, pro.range15, pro.range16, pro.range17, pro.range18, global.pro.rangea, global.pro.rangeb)




# <- ---------
global.plan.rangea <- lmer(plan.range.log ~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
global.plan.rangeb <- lmer(plan.range.log ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)


plan.range1 <- lm(plan.range.log ~ year, data = mpq.1cm) 
plan.range2 <- lm(plan.range.log ~ year + sqrt.hdist.cont, data = mpq.1cm)
plan.range3 <- lm(plan.range.log ~ year * sqrt.hdist.cont, data = mpq.1cm)
plan.range4 <- lm(plan.range.log ~ sqrt.hdist.cont, data = mpq.1cm)

plan.range5 <- lm(plan.range.log ~ year + sqrt.hdist.cont + region.3, data = mpq.1cm) 
plan.range6 <- lm(plan.range.log ~ year * sqrt.hdist.cont + region.3, data = mpq.1cm)
plan.range7 <- lm(plan.range.log~ year + region.3, data = mpq.1cm)

plan.range8 <- lmer(plan.range.log ~ year + sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
plan.range9 <- lmer(plan.range.log ~ year * sqrt.hdist.cont + region.3 + (1|site), data = mpq.1cm)
plan.range10 <- lmer(plan.range.log ~ year + sqrt.hdist.cont + (1|site), data = mpq.1cm)
plan.range11 <- lmer(plan.range.log ~ year * sqrt.hdist.cont + (1|site), data = mpq.1cm)
plan.range12 <- lmer(plan.range.log ~ year + (1|site), data = mpq.1cm)
plan.range13 <- lmer(plan.range.log ~ year + (1|site), data = mpq.1cm)


plan.range14 <- lm(plan.range.log ~ year + sqrt.hdist.cont + island.side, data = mpq.1cm) 
plan.range15 <- lm(plan.range.log ~ year * sqrt.hdist.cont + island.side, data = mpq.1cm)
plan.range16 <- lm(plan.range.log~ year + island.side, data = mpq.1cm)
plan.range17 <- lmer(plan.range.log ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
plan.range18 <- lmer(plan.range.log ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)


## AIC model selection
AIC_plan.range.table <- model.sel(plan.range1,plan.range2,plan.range3,plan.range4,plan.range5,plan.range6,plan.range7,plan.range8,plan.range9,plan.range10,plan.range11,plan.range12, plan.range13, plan.range14, plan.range15, plan.range16, plan.range17, plan.range18, global.plan.rangea, global.plan.rangeb)
```

## VRM
```{r vrm simplfied models}
#Available model variables:
sqrt.hdist.cont #Square Root Transformed Human Disturbance
year #Expedition Year
island.side #2 coarse regions of island side
site #site (as random effect)


#Data
mpq.1cm <- read.csv("~/Desktop/GitHub/Bruce_MPQ_Analysis/Data/BaumLab_Complexity_FULL_1cm_Data_14Jan21.csv", row.names=1)


library(qpcR)

#Models
global.vrm <- lmer(vrm~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)

vrm1 <- lm(vrm ~ year, data = mpq.1cm) 
vrm2 <- lm(vrm ~ year + sqrt.hdist.cont, data = mpq.1cm)
vrm3 <- lm(vrm ~ year * sqrt.hdist.cont, data = mpq.1cm)
vrm4 <- lm(vrm ~ sqrt.hdist.cont, data = mpq.1cm)

vrm5 <- lm(vrm ~ year + sqrt.hdist.cont + island.side, data = mpq.1cm) 
vrm6 <- lm(vrm ~ year * sqrt.hdist.cont + island.side, data = mpq.1cm)
vrm7 <- lm(vrm~ year + island.side, data = mpq.1cm)

vrm8 <- lmer(vrm ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
vrm9 <- lmer(vrm ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
vrm10 <- lmer(vrm ~ year + sqrt.hdist.cont + (1|site), data = mpq.1cm)
vrm11 <- lmer(vrm ~ year * sqrt.hdist.cont + (1|site), data = mpq.1cm)
vrm12 <- lmer(vrm ~ year + (1|site), data = mpq.1cm)
vrm13 <- lmer(vrm ~ year + (1|site), data = mpq.1cm)

## AIC model selection
AIC_vrm.table <- model.sel(vrm1,vrm2,vrm3,vrm4,vrm5,vrm6,vrm7,vrm8,vrm9,vrm10,vrm11,vrm12, vrm13, global.vrm)

## AIC summary table 
names(AIC_vrm.table) <- c("(Int)", "Year", "Human Disturbance", "Disturbance*Year", "Island.Side", "Family", "Model.Class","df", "LL", "AICc", "AICc", "Weight")
AIC_vrm.table$weight <- c(akaike.weights(AIC_vrm.table$AICc)$weights)

#Top Models within 4AIC
summary(vrm6)
summary(vrm5)

```

## Surface Complexity
```{r rug simplfied models}
#Available model variables:
sqrt.hdist.cont #Square Root Transformed Human Disturbance
year #Expedition Year
island.side #2 coarse regions of island side
site #site (as random effect)


#Data
mpq.1cm 

library(qpcR)

#Models
global.rug <- lmer(rug~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)

rug1 <- lm(rug ~ year, data = mpq.1cm) 
rug2 <- lm(rug ~ year + sqrt.hdist.cont, data = mpq.1cm)
rug3 <- lm(rug ~ year * sqrt.hdist.cont, data = mpq.1cm)
rug4 <- lm(rug ~ sqrt.hdist.cont, data = mpq.1cm)

rug5 <- lm(rug ~ year + sqrt.hdist.cont + island.side, data = mpq.1cm) 
rug6 <- lm(rug ~ year * sqrt.hdist.cont + island.side, data = mpq.1cm)
rug7 <- lm(rug~ year + island.side, data = mpq.1cm)

rug8 <- lmer(rug ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
rug9 <- lmer(rug ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
rug10 <- lmer(rug ~ year + sqrt.hdist.cont + (1|site), data = mpq.1cm)
rug11 <- lmer(rug ~ year * sqrt.hdist.cont + (1|site), data = mpq.1cm)
rug12 <- lmer(rug ~ year + (1|site), data = mpq.1cm)
rug13 <- lmer(rug ~ year + (1|site), data = mpq.1cm)

## AIC model selection
AIC_rug.table <- model.sel(rug1,rug2,rug3,rug4,rug5,rug6,rug7,rug8,rug9,rug10,rug11,rug12, rug13, global.rug)

## AIC summary table 
names(AIC_rug.table) <- c("(Int)", "Year", "Human Disturbance", "Disturbance*Year", "Island.Side", "Family", "Model.Class","df", "LL", "AICc", "AICc", "Weight")
AIC_rug.table$weight <- c(akaike.weights(AIC_rug.table$AICc)$weights)

#Top Models within 4AIC
summary(rug5)
summary(rug6)

```

## Fractal Dimension
```{r frac simplfied models}
#Available model variables:
sqrt.hdist.cont #Square Root Transformed Human Disturbance
year #Expedition Year
island.side #2 coarse regions of island side
site #site (as random effect)


#Data
mpq.1cm

library(qpcR)

#Models
global.fractal.dimension <- lmer(fractal.dimension~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)

fractal.dimension1 <- lm(fractal.dimension ~ year, data = mpq.1cm) 
fractal.dimension2 <- lm(fractal.dimension ~ year + sqrt.hdist.cont, data = mpq.1cm)
fractal.dimension3 <- lm(fractal.dimension ~ year * sqrt.hdist.cont, data = mpq.1cm)
fractal.dimension4 <- lm(fractal.dimension ~ sqrt.hdist.cont, data = mpq.1cm)

fractal.dimension5 <- lm(fractal.dimension ~ year + sqrt.hdist.cont + island.side, data = mpq.1cm) 
fractal.dimension6 <- lm(fractal.dimension ~ year * sqrt.hdist.cont + island.side, data = mpq.1cm)
fractal.dimension7 <- lm(fractal.dimension~ year + island.side, data = mpq.1cm)

fractal.dimension8 <- lmer(fractal.dimension ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
fractal.dimension9 <- lmer(fractal.dimension ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
fractal.dimension10 <- lmer(fractal.dimension ~ year + sqrt.hdist.cont + (1|site), data = mpq.1cm)
fractal.dimension11 <- lmer(fractal.dimension ~ year * sqrt.hdist.cont + (1|site), data = mpq.1cm)
fractal.dimension12 <- lmer(fractal.dimension ~ year + (1|site), data = mpq.1cm)
fractal.dimension13 <- lmer(fractal.dimension ~ year + (1|site), data = mpq.1cm)

## AIC model selection
AIC_fractal.dimension.table <- model.sel(fractal.dimension1,fractal.dimension2,fractal.dimension3,fractal.dimension4,fractal.dimension5,fractal.dimension6,fractal.dimension7,fractal.dimension8,fractal.dimension9,fractal.dimension10,fractal.dimension11,fractal.dimension12, fractal.dimension13, global.fractal.dimension)

## AIC summary table 
names(AIC_fractal.dimension.table) <- c("(Int)", "Year", "Human Disturbance", "Disturbance*Year", "Island.Side", "Family", "Model.Class","df", "LL", "AICc", "AICc", "Weight")
AIC_fractal.dimension.table$weight <- c(akaike.weights(AIC_fractal.dimension.table$AICc)$weights)

#Top Models within 4AIC
summary(fractal.dimension6)
summary(fractal.dimension7)
summary(fractal.dimension5)

```

## Profile Curvature Range
```{r pro.range.log simplfied models}
#Available model variables:
sqrt.hdist.cont #Square Root Transformed Human Disturbance
year #Expedition Year
island.side #2 coarse regions of island side
site #site (as random effect)


#Data
mpq.1cm 

library(qpcR)

#Models
global.pro.range.log <- lmer(pro.range.log~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)

pro.range.log1 <- lm(pro.range.log ~ year, data = mpq.1cm) 
pro.range.log2 <- lm(pro.range.log ~ year + sqrt.hdist.cont, data = mpq.1cm)
pro.range.log3 <- lm(pro.range.log ~ year * sqrt.hdist.cont, data = mpq.1cm)
pro.range.log4 <- lm(pro.range.log ~ sqrt.hdist.cont, data = mpq.1cm)

pro.range.log5 <- lm(pro.range.log ~ year + sqrt.hdist.cont + island.side, data = mpq.1cm) 
pro.range.log6 <- lm(pro.range.log ~ year * sqrt.hdist.cont + island.side, data = mpq.1cm)
pro.range.log7 <- lm(pro.range.log~ year + island.side, data = mpq.1cm)

pro.range.log8 <- lmer(pro.range.log ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
pro.range.log9 <- lmer(pro.range.log ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
pro.range.log10 <- lmer(pro.range.log ~ year + sqrt.hdist.cont + (1|site), data = mpq.1cm)
pro.range.log11 <- lmer(pro.range.log ~ year * sqrt.hdist.cont + (1|site), data = mpq.1cm)
pro.range.log12 <- lmer(pro.range.log ~ year + (1|site), data = mpq.1cm)
pro.range.log13 <- lmer(pro.range.log ~ year + (1|site), data = mpq.1cm)

## AIC model selection
AIC_pro.range.log.table <- model.sel(pro.range.log1,pro.range.log2,pro.range.log3,pro.range.log4,pro.range.log5,pro.range.log6,pro.range.log7,pro.range.log8,pro.range.log9,pro.range.log10,pro.range.log11,pro.range.log12, pro.range.log13, global.pro.range.log)

## AIC summary table 
names(AIC_pro.range.log.table) <- c("(Int)", "Year", "Human Disturbance", "Disturbance*Year", "Island.Side", "Family", "Model.Class","df", "LL", "AICc", "AICc", "Weight")
AIC_pro.range.log.table$weight <- c(akaike.weights(AIC_pro.range.log.table$AICc)$weights)

#Top Models within 4AIC
summary(pro.range.log4)
summary(pro.range.log5)
summary(pro.range.log2)


```

## Planform Curvature Range
```{r plan.range.log simplfied models}
#Available model variables:
sqrt.hdist.cont #Square Root Transformed Human Disturbance
year #Expedition Year
island.side #2 coarse regions of island side
site #site (as random effect)


#Data
mpq.1cm 

library(qpcR)

#Models
global.plan.range.log <- lmer(plan.range.log~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)

plan.range.log1 <- lm(plan.range.log ~ year, data = mpq.1cm) 
plan.range.log2 <- lm(plan.range.log ~ year + sqrt.hdist.cont, data = mpq.1cm)
plan.range.log3 <- lm(plan.range.log ~ year * sqrt.hdist.cont, data = mpq.1cm)
plan.range.log4 <- lm(plan.range.log ~ sqrt.hdist.cont, data = mpq.1cm)

plan.range.log5 <- lm(plan.range.log ~ year + sqrt.hdist.cont + island.side, data = mpq.1cm) 
plan.range.log6 <- lm(plan.range.log ~ year * sqrt.hdist.cont + island.side, data = mpq.1cm)
plan.range.log7 <- lm(plan.range.log~ year + island.side, data = mpq.1cm)

plan.range.log8 <- lmer(plan.range.log ~ year + sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
plan.range.log9 <- lmer(plan.range.log ~ year * sqrt.hdist.cont + island.side + (1|site), data = mpq.1cm)
plan.range.log10 <- lmer(plan.range.log ~ year + sqrt.hdist.cont + (1|site), data = mpq.1cm)
plan.range.log11 <- lmer(plan.range.log ~ year * sqrt.hdist.cont + (1|site), data = mpq.1cm)
plan.range.log12 <- lmer(plan.range.log ~ year + (1|site), data = mpq.1cm)
plan.range.log13 <- lmer(plan.range.log ~ year + (1|site), data = mpq.1cm)

## AIC model selection
AIC_plan.range.log.table <- model.sel(plan.range.log1,plan.range.log2,plan.range.log3,plan.range.log4,plan.range.log5,plan.range.log6,plan.range.log7,plan.range.log8,plan.range.log9,plan.range.log10,plan.range.log11,plan.range.log12, plan.range.log13, global.plan.range.log)

## AIC summary table 
names(AIC_plan.range.log.table) <- c("(Int)", "Year", "Human Disturbance", "Disturbance*Year", "Island.Side", "Family", "Model.Class","df", "LL", "AICc", "AICc", "Weight")
AIC_plan.range.log.table$weight <- c(akaike.weights(AIC_plan.range.log.table$AICc)$weights)

#Top Models within 4AIC
summary(plan.range.log2)
summary(plan.range.log5)

```

## Habitat Volume
```{r hab.vol simplified models}
CC.final <- read.csv("~/Desktop/GitHub/Bruce_MPQ_Analysis/Data/BaumLab_CloudCompare_Data_FINAL_14Jan2021.csv", row.names = 1)


#Subset out the overall changes in data (2015-2019 datapoints)
cc <- subset(CC.final, timepoint == "2015-2017" | timepoint == "2017-2019")

#Level time interval
cc$time.interval <- factor(cc$time.interval, levels = c("'15-'17","'17-'19"))


#Available model variables:
sqrt.hdist.cont #Square Root Transformed Human Disturbance
time.interval #Time interval between two samples taken
island.side #2 coarse regions of island side
site #site (as random effect)
cc

library(qpcR)

#Models
global.volume.change <- lmer(volume.change~ time.interval * sqrt.hdist.cont + island.side + (1|site), data = cc)

volume.change1 <- lm(volume.change ~ time.interval, data = cc) 
volume.change2 <- lm(volume.change ~ time.interval + sqrt.hdist.cont, data = cc)
volume.change3 <- lm(volume.change ~ time.interval * sqrt.hdist.cont, data = cc)
volume.change4 <- lm(volume.change ~ sqrt.hdist.cont, data = cc)

volume.change5 <- lm(volume.change ~ time.interval + sqrt.hdist.cont + island.side, data = cc) 
volume.change6 <- lm(volume.change ~ time.interval * sqrt.hdist.cont + island.side, data = cc)
volume.change7 <- lm(volume.change~ time.interval + island.side, data = cc)

volume.change8 <- lmer(volume.change ~ time.interval + sqrt.hdist.cont + island.side + (1|site), data = cc)
volume.change9 <- lmer(volume.change ~ time.interval * sqrt.hdist.cont + island.side + (1|site), data = cc)
volume.change10 <- lmer(volume.change ~ time.interval + sqrt.hdist.cont + (1|site), data = cc)
volume.change11 <- lmer(volume.change ~ time.interval * sqrt.hdist.cont + (1|site), data = cc)
volume.change12 <- lmer(volume.change ~ time.interval + (1|site), data = cc)
volume.change13 <- lmer(volume.change ~ time.interval + (1|site), data = cc)

## AIC model selection
AIC_volume.change.table <- model.sel(volume.change1,volume.change2,volume.change3,volume.change4,volume.change5,volume.change6,volume.change7,volume.change8,volume.change9,volume.change10,volume.change11,volume.change12, volume.change13, global.volume.change)

## AIC summary table 
names(AIC_volume.change.table) <- c("(Int)", "time.interval", "Human Disturbance", "Disturbance*time.interval", "Island.Side", "Family", "Model.Class","df", "LL", "AICc", "AICc", "Weight")
AIC_volume.change.table$weight <- c(akaike.weights(AIC_volume.change.table$AICc)$weights)

#Top Models within 4AIC
summary(volume.change7)
summary(volume.change5)
summary(volume.change6)
summary(volume.change1)



```







#a 